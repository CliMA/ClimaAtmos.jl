<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Diagnostics · ClimaAtmos.jl</title><meta name="title" content="Diagnostics · ClimaAtmos.jl"/><meta property="og:title" content="Diagnostics · ClimaAtmos.jl"/><meta property="twitter:title" content="Diagnostics · ClimaAtmos.jl"/><meta name="description" content="Documentation for ClimaAtmos.jl."/><meta property="og:description" content="Documentation for ClimaAtmos.jl."/><meta property="twitter:description" content="Documentation for ClimaAtmos.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaAtmos.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../contributor_guide/">Contributor Guide</a></li><li><a class="tocitem" href="../equations/">Equations</a></li><li><a class="tocitem" href="../edmf_equations/">EDMF Equations</a></li><li class="is-active"><a class="tocitem" href>Diagnostics</a><ul class="internal"><li><a class="tocitem" href="#I-want-to-compute-and-output-a-diagnostic-variable"><span>I want to compute and output a diagnostic variable</span></a></li><li><a class="tocitem" href="#I-want-to-add-a-new-diagnostic-variable"><span>I want to add a new diagnostic variable</span></a></li></ul></li><li><a class="tocitem" href="../available_diagnostics/">Available Diagnostics</a></li><li><a class="tocitem" href="../diagnostic_edmf_equations/">Diagnostic EDMF Equations</a></li><li><a class="tocitem" href="../gravity_wave/">Gravity Wave Drag Parameterizations</a></li><li><a class="tocitem" href="../radiative_equilibrium/">Radiative Equilibrium</a></li><li><a class="tocitem" href="../repl_scripts/">REPL scripts</a></li><li><a class="tocitem" href="../config/">Configuration</a></li><li><a class="tocitem" href="../parameters/">Parameters</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Diagnostics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Diagnostics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaAtmos.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaAtmos.jl/blob/main/docs/src/diagnostics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Computing-and-saving-diagnostics"><a class="docs-heading-anchor" href="#Computing-and-saving-diagnostics">Computing and saving diagnostics</a><a id="Computing-and-saving-diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-and-saving-diagnostics" title="Permalink"></a></h1><h2 id="I-want-to-compute-and-output-a-diagnostic-variable"><a class="docs-heading-anchor" href="#I-want-to-compute-and-output-a-diagnostic-variable">I want to compute and output a diagnostic variable</a><a id="I-want-to-compute-and-output-a-diagnostic-variable-1"></a><a class="docs-heading-anchor-permalink" href="#I-want-to-compute-and-output-a-diagnostic-variable" title="Permalink"></a></h2><h3 id="From-a-YAML-file"><a class="docs-heading-anchor" href="#From-a-YAML-file">From a YAML file</a><a id="From-a-YAML-file-1"></a><a class="docs-heading-anchor-permalink" href="#From-a-YAML-file" title="Permalink"></a></h3><p>If you configure your simulation with YAML files, there are two options that are important to know about. When <code>output_default_diagnostics</code> is set to <code>true</code>, the default diagnostics for the given atmospheric model will be output. Note that they might be incompatible with your simulation (e.g., you want to output hourly maxima when the timestep is 4 hours).</p><p>Second, you can specify the diagnostics you want to output directly in the <code>diagnostics</code> section of your YAML file. For instance:</p><pre><code class="nohighlight hljs">diagnostics:
  - short_name: rhoa
    output_name: a_name
    period: 3hours
    writer: nc
  - reduction_time: average
    short_name: rhoa
    period: 12hours
    writer: h5</code></pre><p>This adds two diagnostics (both for <code>rhoa</code>). The <code>period</code> keyword identifies the period over which to compute the reduction and how often to save to disk. <code>output_name</code> is optional, and if provided, it identifies the name of the output file.</p><p>The default <code>writer</code> is HDF5. If <code>writer</code> is <code>nc</code> or <code>netcdf</code>, the output is remapped non-conservatively on a Cartesian grid and saved to a NetCDF file. Currently, only 3D fields on cubed spheres are supported.</p><h3 id="From-a-script"><a class="docs-heading-anchor" href="#From-a-script">From a script</a><a id="From-a-script-1"></a><a class="docs-heading-anchor-permalink" href="#From-a-script" title="Permalink"></a></h3><p>The simplest way to get started with diagnostics is to use the defaults for your atmospheric model. <code>ClimaAtmos</code> defines a function <code>default_diagnostic</code>. You can execute this function on an <code>AtmosModel</code> or on any of its fields to obtain a list of diagnostics ready to be passed to the simulation. So, for example</p><pre><code class="language-julia hljs">
model = ClimaAtmos.AtmosModel(..., moisture_model = ClimaAtmos.DryModel(), ...)

diagnostics = ClimaAtmos.default_diagnostics(model)
# =&gt; List of diagnostics that include the ones specified for the DryModel</code></pre><p>Technically, the diagnostics are represented as <code>ScheduledDiagnostic</code> objects, which contain information about what variable has to be computed, how often, where to save it, and so on (read below for more information on this). You can construct your own lists of <code>ScheduledDiagnostic</code>s starting from the variables defined by <code>ClimaAtmos</code>. The <code>DiagnosticVariable</code>s in <code>ClimaAtmos</code> are identified with by the short and unique name, so that you can access them directly with the function <code>diagnostic_variable</code>. One way to do so is by using the provided convenience functions for common operations, e.g., continuing the previous example</p><pre><code class="language-julia hljs">
push!(diagnostics, daily_max(&quot;air_density&quot;, &quot;air_temperature&quot;))</code></pre><p>Now <code>diagnostics</code> will also contain the instructions to compute the daily maximum of <code>air_density</code> and <code>air_temperature</code>.</p><p>The diagnostics that are built-in <code>ClimaAtmos</code> are collected in <a href="../available_diagnostics/#Available-diagnostic-variables">Available diagnostic variables</a>.</p><p>If you are using <code>ClimaAtmos</code> with a script-based interface, you have access to the complete flexibility in your diagnostics. Read the section about the low-level interface to see how to implement custom diagnostics, reductions, or writers.</p><h3 id="The-low-level-interface"><a class="docs-heading-anchor" href="#The-low-level-interface">The low-level interface</a><a id="The-low-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-low-level-interface" title="Permalink"></a></h3><p>Diagnostics are computed and output through callbacks to the main integrator. <code>ClimaAtmos</code> produces the list of callbacks from a ordered list of <code>ScheduledDiagnostic</code>s. These callbacks are orchestrated by a callback <code>orchestrate_diagnostics</code> that runs at the end of every step and calls all the diagnostic callbacks that are scheduled to be run at that step.</p><p>A <code>ScheduledDiagnostic</code> is an instruction on how to compute and output a given <code>DiagnosticVariable</code> (see below), along with specific choices regarding reductions, compute/output frequencies, and so on. It can be point-wise in space and time, or can be the result of a reduction in a period that is defined by <code>output_every</code> (e.g., the daily average temperature).</p><p>More specifically, a <code>ScheduledDiagnostic</code> contains the following pieces of data</p><ul><li><code>variable</code>: The diagnostic variable that has to be computed and output.</li><li><code>output_every</code>: Frequency of how often to save the results to disk.</li><li><code>output_writer</code>: Function that controls out to save the computed diagnostic variable to disk.</li><li><code>reduction_time_func</code>: If not <code>nothing</code>, the <code>ScheduledDiagnostic</code> receives an area of scratch space <code>acc</code> where to accumulate partial results. Then, at every <code>compute_every</code>, <code>reduction_time_func</code> is computed between the previously stored value in <code>acc</code> and the new value. This implements a running reduction. For example, if <code>reduction_time_func = max</code>, the space <code>acc</code> will hold the running maxima of the diagnostic. <code>acc</code> is reset after output.</li><li><code>reduction_space_func</code>: NOT IMPLEMENTED YET</li><li><code>compute_every</code>: Run the computations every <code>compute_every</code>. This is not particularly useful for point-wise diagnostics, where we enforce that <code>compute_every</code> = <code>output_every</code>. <code>compute_every</code> has to evenly divide <code>output_every</code>.</li><li><code>pre_output_hook!</code>: Function that has to be run before saving to disk for  reductions (mostly used to implement averages). The function  <code>pre_output_hook!</code> is called with two arguments: the value accumulated during  the reduction, and the number of times the diagnostic was computed from the  last time it was output.</li><li><code>output_short_name</code>: A descriptive name that can be used by the  <code>output_writer</code>. If not provided, a default one is generated. It has to be  unique.</li><li><code>output_long_name</code>: A descriptive name that can be used by the <code>output_writer</code>  as attribute. If not provided, a default one is generated.</li></ul><p>To implement operations like the arithmetic average, the <code>reduction_time_func</code> has to be chosen as <code>+</code>, and a <code>pre_output_hook!</code> that renormalize <code>acc</code> by the number of samples has to be provided. <code>pre_output_hook!</code> should mutate the accumulator in place. The return value of <code>pre_output_hook!</code> is discarded. An example of <code>pre_output_hook!</code> to compute the arithmetic average is <code>pre_output_hook!(acc, N) = @. acc = acc / N</code>. <code>ClimaAtmos</code> provides an alias to the function needed to compute averages <code>ClimaAtmos.average_pre_output_hook!</code>.</p><p>For custom reductions, it is necessary to also specify the identity of operation by defining a new method to <code>identity_of_reduction</code>. <code>identity_of_reduction</code> is a function that takes a <code>op</code> argument, where <code>op</code> is the operation for which we want to define the identity. For instance, for the <code>max</code>, <code>identity_of_reduction</code> would be <code>identity_of_reduction(::typeof{max}) = -Inf</code>. The identities known to <code>ClimaAtmos</code> are defined in the <code>diagnostics/reduction_identities.jl</code> file. The identity is needed to ensure that we have a neutral state for the accumulators that are used in the reductions.</p><p>A key entry in a <code>ScheduledDiagnostic</code> is the <code>output_writer</code>, the function responsible for saving the output to disk. <code>output_writer</code> is called with three arguments: the value that has to be output, the <code>ScheduledDiagnostic</code>, and the integrator. Internally, the integrator contains extra information (such as the current timestep), so the <code>output_writer</code> can implement arbitrarily complex behaviors. It is responsibility of the <code>output_writer</code> to properly use the provided information for meaningful output. <code>ClimaAtmos</code> provides functions that return <code>output_writer</code>s for standard operations. The main one is currently <code>HDF5Writer</code>, which should be enough for most use cases. To use it, just initialize a <code>ClimaAtmos.HDF5Writer</code> object with your choice of configuration and pass it as a <code>output_writer</code> argument to the <code>ScheduledDiagnostic</code>. More information about the options supported by <code>ClimaAtmos.HDF5Writer</code> is available in its constructor.</p><p>There are two flavors of <code>ScheduledDiagnostic</code>s: <code>ScheduledDiagnosticIterations</code>, and <code>ScheduledDiagnosticTime</code>. The main difference between the two is the domain of definition of their frequencies, which is measured in timesteps for the first one, and in seconds for the other one. <code>ScheduledDiagnosticTime</code>s offer a more natural way to set up physically meaningful reductions (e.g., we want a daily average). However, it is not clear what to do when the period does not line up with the timestep. What is the expected behavior when we want a daily average but our timestep is of 10 hours? There are multiple possible answer to this question. In <code>ClimaAtmos</code>, we enforce that all the periods are multiples of the timestep. With this restriction, a <code>ScheduledDiagnosticTime</code> can be translated to a <code>ScheduledDiagnosticIterations</code>, where the problem is perfectly represented (in this sense, one can think of <code>ScheduledDiagnosticIterations</code> as being as internal representation and as <code>ScheduledDiagnosticTime</code> being the user-facing one).</p><p><code>ScheduledDiagnosticTime</code> behave like as <code>ScheduledDiagnosticIterations</code>, with the exception that they can take a special value for <code>compute_every</code>, which can be set to <code>:timestep</code> (the symbol) to ensure that the diagnostic is computed at the end of every integration step. This is particularly convenient when defining default diagnostics, as they should be largely independent on the choice of the specific simulation being run (and its timestep).</p><p>Given a timestep <code>dt</code>, a <code>ScheduledDiagnosticIterations</code> can be obtained from a <code>ScheduledDiagnosticTime</code> <code>sd</code> simply by calling `<code>ScheduledDiagnosticIterations(sd, dt)</code>.</p><h2 id="I-want-to-add-a-new-diagnostic-variable"><a class="docs-heading-anchor" href="#I-want-to-add-a-new-diagnostic-variable">I want to add a new diagnostic variable</a><a id="I-want-to-add-a-new-diagnostic-variable-1"></a><a class="docs-heading-anchor-permalink" href="#I-want-to-add-a-new-diagnostic-variable" title="Permalink"></a></h2><p>Diagnostic variables are represented in <code>ClimaAtmos</code> with a <code>DiagnosticVariable</code> <code>struct</code>. Fundamentally, a <code>DiagnosticVariable</code> contains metadata about the variable, and a function that computes it from the state.</p><h3 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h3><p>The metadata we currently support is <code>short_name</code>, <code>long_name</code>, <code>units</code>, <code>comments</code>. This metadata is relevant mainly in the context of how the variable is output. Therefore, it is responsibility of the <code>output_writer</code> (see <code>ScheduledDiagnostic</code>) to handle the metadata properly. The <code>output_writer</code>s provided by <code>ClimaAtmos</code> use this metadata.</p><p>In <code>ClimaAtmos</code>, we follow the convention that:</p><ul><li><p><code>short_name</code> is the name used to identify the variable in the output files and               in the file names. It is short, but descriptive. We identify               diagnostics by their short name, so the diagnostics defined by               <code>ClimaAtmos</code> have to have unique <code>short_name</code>s.</p></li><li><p><code>long_name</code>: Name used to describe the variable in the output file as attribute.</p></li><li><p><code>standard_name</code>: Standard name, as in <a href="http://cfconventions.org/Data/cf-standard-names/71/build/cf-standard-name-table.html">CF conventions</a></p></li><li><p><code>units</code>: Physical units of the variable.</p></li><li><p><code>comments</code>: More verbose explanation of what the variable is, or comments related to how             it is defined or computed.</p></li></ul><p>In <code>ClimaAtmos</code>, we follow the <a href="https://airtable.com/appYNLuWqAgzLbhSq/shrKcLEdssxb8Yvcp/tblL7dJkC3vl5zQLb">CMIP6 MIP table</a> for short names and long names where available. Standard names in the table are not used.</p><h3 id="Compute-function"><a class="docs-heading-anchor" href="#Compute-function">Compute function</a><a id="Compute-function-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-function" title="Permalink"></a></h3><p>The other piece of information needed to specify a <code>DiagnosticVariable</code> is a function <code>compute!</code>. Schematically, a <code>compute!</code> has to look like</p><pre><code class="language-julia hljs">function compute!(out, state, cache, time)
    if isnothing(out)
        return ... # Calculations with the state and the cache
    else
        out .= ... # Calculations with the state and the cache
    end
end</code></pre><p>The first time <code>compute!</code> is called, the function has to allocate memory and return its output. All the subsequent times, <code>out</code> will be the pre-allocated area of memory, so the function has to write the new value in place.</p><p>Diagnostics are implemented as callbacks functions which pass the <code>state</code>, <code>cache</code>, and <code>time</code> from the integrator to <code>compute!</code>.</p><p><code>compute!</code> also takes a second argument, <code>out</code>, which is used to avoid extra memory allocations (which hurt performance). If <code>out</code> is <code>nothing</code>, and new area of memory is allocated. If <code>out</code> is a <code>ClimaCore.Field</code>, the operation is done in-place without additional memory allocations.</p><p>If your diagnostic depends on the details of the model, we recommend using additional functions so that the correct one can be found through dispatching. For instance, if you want to compute relative humidity, which does not make sense for dry simulations, you should define the functions</p><pre><code class="language-julia hljs">function compute_relative_humidity!(
    out,
    state,
    cache,
    time,
    moisture_model::T,
) where {T}
    error(&quot;Cannot compute relative_humidity with moisture_model = $T&quot;)
end

function compute_relative_humidity!(
    out,
    state,
    cache,
    time,
    moisture_model::T,
) where {T &lt;: Union{EquilMoistModel, NonEquilMoistModel}}
    if isnothing(out)
        return TD.relative_humidity.(thermo_params, cache.ᶜts)
    else
        out .= TD.relative_humidity.(thermo_params, cache.ᶜts)
    end
end

compute_relative_humidity!(out, state, cache, time) =
    compute_relative_humidity!(
        out,
        state,
        cache,
        time,
        cache.atmos.moisture_model,
    )</code></pre><p>This will return the correct relative humidity and throw informative errors when it cannot be computed. We could specialize <code>compute_relative_humidity</code> further if the relative humidity were computed differently for <code>EquilMoistModel</code> and <code>NonEquilMoistModel</code>.</p><p>In <code>ClimaAtmos</code>, we define some helper functions to produce error messages, so the above code can be written as</p><pre><code class="language-julia hljs">compute_relative_humidity!(out, state, cache, time) =
    compute_relative_humidity!(out, state, cache, time, cache.atmos.moisture_model)
compute_relative_humidity!(_, _, _, _, model::T) where {T} =
    error_diagnostic_variable(&quot;relative_humidity&quot;, model)

function compute_relative_humidity!(
    out,
    state,
    cache,
    time,
    ::T,
) where {T &lt;: Union{EquilMoistModel, NonEquilMoistModel}}
    thermo_params = CAP.thermodynamics_params(cache.params)
    if isnothing(out)
        return TD.relative_humidity.(thermo_params, cache.ᶜts)
    else
        out .= TD.relative_humidity.(thermo_params, cache.ᶜts)
    end
end</code></pre><h3 id="The-ClimaAtmos-DiagnosticVariables"><a class="docs-heading-anchor" href="#The-ClimaAtmos-DiagnosticVariables">The <code>ClimaAtmos</code> <code>DiagnosticVariable</code>s</a><a id="The-ClimaAtmos-DiagnosticVariables-1"></a><a class="docs-heading-anchor-permalink" href="#The-ClimaAtmos-DiagnosticVariables" title="Permalink"></a></h3><p><code>ClimaAtmos</code> comes with a collection of pre-defined <code>DiagnosticVariable</code>, index with their <code>short_name</code>s. If you are extending <code>ClimaAtmos</code> and want to add a new diagnostic variable, go ahead and look at the files we <code>include</code> in <code>diagnostics/Diagnostics.jl</code>. You can add more diagnostics in those files or add a new one. We provide a convenience function, <code>add_diagnostic_variable!</code> to add new <code>DiagnosticVariable</code>s. <code>add_diagnostic_variable!</code> take the same arguments as the constructor for <code>DiagnosticVariable</code>, but also performs additional checks. Similarly, if you want to retrieve a diagnostic from <code>ALL_DIAGNOSTICS</code>, use the <code>get_diagnostic_variable</code>function.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../edmf_equations/">« EDMF Equations</a><a class="docs-footer-nextpage" href="../available_diagnostics/">Available Diagnostics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Wednesday 8 November 2023 05:03">Wednesday 8 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
