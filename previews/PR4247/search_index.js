var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"A. Sridhar, Y. Tissaoui, S. Marras, Z. Shen, C. Kawczynski, S. Byrne, K. Pamnany, M. Waruszewski, T. H. Gibson, J. E. Kozdon, V. Churavy, L. C. Wilcox, F. X. Giraldo and T. Schneider. Large-eddy simulations with ClimateMachine v0.2.0: a new open-source code for atmospheric simulations on GPUs and CPUs. Geosci. Model Dev. 15, 6259–6284 (2022).\n\n\n\nM. Abkar, H. J. Bae and P. Moin. Minimum-dissipation scalar transport model for large-eddy simulation of turbulent flows. Phys. Rev. Fluids 1, 041701 (2016).\n\n\n\nJ. M. Alexander and T. J. Dunkerton. A spectral parameterization of mean-flow forcing due to breaking gravity waves. Journal of the Atmospheric Sciences 56, 4167–4182 (1999).\n\n\n\nR. S. Lindzen. Turbulence and stress owing to gravity wave and tidal breakdown. Journal of Geophysical Research: Oceans 86, 9707–9714 (1981).\n\n\n\nS. T. Garner. A Topographic Drag Closure Built on an Analytical Base Flux. Journal of the Atmospheric Sciences 62, 2302–2315 (2005).\n\n\n\nP. A. O’Gorman and T. Schneider. The Hydrological Cycle over a Wide Range of Climates Simulated with an Idealized GCM. Journal of Climate 21, 3815–3832 (2008).\n\n\n\nand W. Yi. A new parameterization of spectral and broadband ocean surface albedo. Opt. Express 19, 26429–26443 (2011).\n\n\n\nT. J. Warren, N. E. Bowles, K. Donaldson Hanna and J. L. Bandfield. Modeling the angular dependence of emissivity of randomly rough surfaces. Journal of Geophysical Research: Planets 124, 585–601 (2019).\n\n\n\nB. Kosović and J. A. Curry. A large eddy simulation study of a quasi-steady, stably stratified atmospheric boundary layer. J. Atmos. Sci. 57, 1052–1068 (2000).\n\n\n\nB. Stevens, C.-H. Moeng, A. S. Ackerman, C. S. Bretherton, A. Chlond, S. de Roode, J. Edwards, J.-C. Golaz, H. Jiang, M. Khairoutdinov and others. Evaluation of large-eddy simulations via observations of nocturnal marine stratocumulus. Monthly weather review 133, 1443–1462 (2005).\n\n\n\nA. S. Ackerman, M. C. vanZanten, B. Stevens, V. Savic-Jovcic, C. S. Bretherton, A. Chlond, J.-C. Golaz, H. Jiang, M. Khairoutdinov, S. K. Krueger, D. C. Lewellen, A. Lock, C.-H. Moeng, K. Nakamura, M. D. Petters, J. R. Snider, S. Weinbrecht and M. Zulauf. Large-Eddy Simulations of a Drizzling, Stratocumulus-Topped Marine Boundary Layer. Monthly Weather Review 137, 1083–1110 (2009).\n\n\n\nR. M. Rauber, B. Stevens, H. T. Ochs, C. Knight, B. A. Albrecht, A. M. Blyth, C. W. Fairall, J. B. Jensen, S. G. Lasher-Trapp, O. L. Mayol-Bracero, G. Vali, J. R. Anderson, B. A. Baker, A. R. Bandy, E. Burnet, J.-L. Brenguier, W. A. Brewer, P. R. Brown, R. Chuang, W. R. Cotton, L. D. Girolamo, B. Geerts, H. Gerber, S. Göke, L. Gomes, B. G. Heikes, J. G. Hudson, P. Kollias, R. R. Lawson, S. K. Krueger, D. H. Lenschow, L. Nuijens, D. W. O'Sullivan, R. A. Rilling, D. C. Rogers, A. P. Siebesma, E. Snodgrass, J. L. Stith, D. C. Thornton, S. Tucker, C. H. Twohy and P. Zuidema. Rain in Shallow Cumulus Over the Ocean: The RICO Campaign. Bulletin of the American Meteorological Society 88, 1912–1928 (2007).\n\n\n\nW. Grabowski, P. Bechtold, A. Cheng, R. Forbes, C. Halliwell, M. Khairoutdinov, S. Lang, T. Nasuno, J. Petch, W.-K. Tao and others. Daytime convective development over land: A model intercomparison based on LBA observations. Quarterly Journal of the Royal Meteorological Society: A journal of the atmospheric sciences, applied meteorology and physical oceanography 132, 317–344 (2006).\n\n\n\nJ. Z. HOLLAND and E. M. RASMUSSON. Measurements of the Atmospheric Mass, Energy, and Momentum Budgets Over a 500-Kilometer Square of Tropical Ocean. Monthly Weather Review 101, 44–55 (1973).\n\n\n\nP. Soares, P. Miranda, A. Siebesma and J. Teixeira. An eddy-diffusivity/mass-flux parametrization for dry and shallow cumulus convection. Quarterly Journal of the Royal Meteorological Society: A journal of the atmospheric sciences, applied meteorology and physical oceanography 130, 3365–3383 (2004).\n\n\n\n","category":"section"},{"location":"edmf_equations/#Sub-grid-scale-equations","page":"EDMF Equations","title":"Sub-grid scale equations","text":"This describes the EDMF scheme equations and its discretizations. Where possible, we use a coordinate invariant form: the ClimaCore operators generally handle the conversions between bases internally.","category":"section"},{"location":"edmf_equations/#Dycore-variables","page":"EDMF Equations","title":"Dycore variables","text":"boldsymbolOmega is the planetary angular velocity. We currently use a shallow-atmosphere approximation, with\nboldsymbolOmega = Omega sin(phi) boldsymbole^v\nwhere phi is latitude, and Omega is the planetary rotation rate in rads/sec (for Earth, 729212 times 10^-5 s^-1) and boldsymbole^v is the unit radial basis vector. This implies that the horizontal contravariant component boldsymbolOmega^h is zero.\nboldsymbolu_h = u_1 boldsymbole^1 + u_2 boldsymbole^2 is the projection onto horizontal covariant components (covariance here means with respect to the reference element), stored at cell centers.\nPhi = g z is the geopotential, where g is the gravitational acceleration rate and z is altitude above the mean sea level.\nrho_textref is the reference state density\np is air pressure, derived from the thermodynamic state, reconstructed at cell centers.\np_textref is the reference state pressure. It is related to the reference state density by analytical hydrostatic balance: nabla p_textref = - rho_textref nabla Phi.","category":"section"},{"location":"edmf_equations/#Prognostic-variables","page":"EDMF Equations","title":"Prognostic variables","text":"hatrho^j: effective density in kg/m³. Superscript j represents the sub-domain. hatrho^j = rho^j a^j where rho^j is the sub-domain density and a^j is the sub-domain area fraction. This is discretized at cell centers.\nboldsymbolu^j velocity, a vector in m/s. This is discretized via boldsymbolu^j = boldsymbolu_h + boldsymbolu_v^j where\nboldsymbolu_v^j = u_3^j boldsymbole^3 is the projection onto the vertical covariant components, stored at cell faces.\nhatrho^j e^j: total energy in J/m³. This is discretized at cell centers.\nhatrho^j q^j: moisture tracers. q^j stands for the sub-domain total (liquid, ice, rain, snow) specific humidity in kg/kg. This is stored at cell centers.\nhatrho^j chi^j: other tracers (aerosol, ...), again stored at cell centers.","category":"section"},{"location":"edmf_equations/#Operators","page":"EDMF Equations","title":"Operators","text":"We make use of the following operators","category":"section"},{"location":"edmf_equations/#Reconstruction","page":"EDMF Equations","title":"Reconstruction","text":"I^c is the face-to-center reconstruction operator (arithmetic mean)\nI^f is the center-to-face reconstruction operator (arithmetic mean)\nWI^f is the center-to-face weighted reconstruction operator\nWI^f(J x) = I^f(J*x)  I^f(J), where J is the value of the Jacobian for use in the weighted interpolation operator\nU^f is the 1st or 3rd-order center-to-face upwind product operator # fix link","category":"section"},{"location":"edmf_equations/#Differential-operators","page":"EDMF Equations","title":"Differential operators","text":"D_h is the discrete horizontal spectral divergence.\nhatmathcalD_h is the discrete horizontal spectral weak divergence.\nD^c_v is the face-to-center vertical divergence.\nG_h is the discrete horizontal spectral gradient.\nG^f_v is the center-to-face vertical gradient.\nthe gradient is set to 0 at the top and bottom boundaries.\nC_h is the curl components involving horizontal derivatives\nC_hboldsymbolu_h returns a vector with only vertical contravariant components.\nC_hboldsymbolu_v returns a vector with only horizontal contravariant components.\nhatmathcalC_h is the weak curl components involving horizontal derivatives\nC^f_v is the center-to-face curl involving vertical derivatives.\nC^f_vboldsymbolu_h returns a vector with only a horizontal contravariant component.\nthe curl is set to 0 at the top and bottom boundaries.\nWe need to clarify how best to handle this.","category":"section"},{"location":"edmf_equations/#Projection","page":"EDMF Equations","title":"Projection","text":"mathcalP is the direct stiffness summation (DSS) operation, which computes the projection onto the continuous spectral element basis.","category":"section"},{"location":"edmf_equations/#Auxiliary-and-derived-quantities","page":"EDMF Equations","title":"Auxiliary and derived quantities","text":"tildeboldsymbolu^j is the mass-weighted reconstruction of velocity at the interfaces: by interpolation of contravariant components\ntildeboldsymbolu^j = WI^f left( rho^j J boldsymbolu_h right) + boldsymbolu_v^j\n\nTechnically, from mass conservation, the weighting factor should be hatrho^j J. However, in order to avoid issues coming from close to zero sub-domain area fractions, we can instead use rho^j J or even rho J.\n\nbarboldsymbolu^j is the reconstruction of velocity at cell-centers, carried out by linear interpolation of the covariant vertical component:\nbarboldsymbolu^j = boldsymbolu_h + I_c(boldsymbolu_v^j)\nboldsymbolb^j is the reduced gravitational acceleration\nboldsymbolb^j = - fracrho^j - rho_textrefrho^j nabla Phi\nK^j = tfrac12 boldsymbolu^j^2 is the specific kinetic energy (J/kg), reconstructed at cell centers by\nK^j = tfrac12 left(boldsymbolu_h^j cdot boldsymbolu_h^j + 2 boldsymbolu_h^j cdot I_c (boldsymbolu_v^j) + I_c(boldsymbolu_v^j cdot boldsymbolu_v^j) right)\nwhere boldsymbolu_h^j is defined on cell-centers, boldsymbolu_v^j is defined on cell-faces, and I_c (boldsymbolu_v) is interpolated using covariant components.\nnu_u, nu_h, and nu_chi are hyperdiffusion coefficients, and c is the divergence damping factor.\nNo-flux boundary conditions are enforced by requiring the third contravariant component of the face-valued velocity at the boundary, boldsymboltildeu^vj, to be zero. The vertical covariant velocity component is computed as\ntildeu_v^j = - fracu_1g^31 + u_2g^32g^33","category":"section"},{"location":"edmf_equations/#Equations-and-discretizations","page":"EDMF Equations","title":"Equations and discretizations","text":"","category":"section"},{"location":"edmf_equations/#Mass","page":"EDMF Equations","title":"Mass","text":"Follows the continuity equation\n\nfracpartialpartial t hatrho^j = - nabla cdot (hatrho^j boldsymbolu^j)  + RHS\n\nThis is discretized using the following\n\nfracpartialpartial t hatrho^j\n= - D_h left hatrho^j (boldsymbolu_h + I^c(boldsymbolu_v^j)) right - D^c_v leftWI^f( J hatrho^j) tildeboldsymbolu^j right + RHS","category":"section"},{"location":"edmf_equations/#Momentum","page":"EDMF Equations","title":"Momentum","text":"Uses the advective form equation\n\nfracpartialpartial t boldsymbolu^j  = - (2 boldsymbolOmega + nabla times boldsymbolu^j) times boldsymbolu^j - frac1rho^j nabla (p - p_textref)  + boldsymbolb^j - nabla K^j + RHS\n\nBy breaking the curl and cross product terms into horizontal and vertical contributions, and removing zero terms (e.g. nabla_v  times boldsymbolu_v = 0), we obtain the vertical momentum equation. The horizontal momentum equation is only solved in the grid-mean.","category":"section"},{"location":"edmf_equations/#Vertical-momentum","page":"EDMF Equations","title":"Vertical momentum","text":"fracpartialpartial t boldsymbolu_v^j  =\n  - (nabla_v times boldsymbolu_h + nabla_h times boldsymbolu_v^j) times boldsymbolu^h\n  - frac1rho^j nabla_v (p - p_textref) - fracrho^j - rho_textrefrho^j nabla_v Phi - nabla_v K^j + RHS \n\nThis is stabilized with the addition of 4th-order vector hyperviscosity\n\n-nu_u nabla_h^2(nabla_h^2(boldsymbolu^j))\n\nprojected onto the third contravariant direction.\n\nThe (nabla_v times boldsymbolu_h + nabla_h times boldsymbolu_v^j) times boldsymbolu^h term is discretized as\n\n(C^f_vboldsymbolu_h + C_hboldsymbolu_v^j) times I^f(boldsymbolu^h) \n\nand the -frac1rho^j nabla_v (p - p_textref) - fracrho^j - rho_textrefrho^j nabla_v Phi - nabla_v K^j terms as\n\n-frac1I^f(rho^j) G^f_vp - p_textref - fracI^f(rho^j - rho_textref)I^f(rho^j) G^f_vPhi - G^f_vK^j \n\nThe hyperviscosity term is\n\n- nu_u hatmathcalD_h (mathcalG_h (psi) )\n\nwhere\n\npsi = mathcalP left hatmathcalD_h left( mathcalG_h (w^j)right) right","category":"section"},{"location":"edmf_equations/#Total-energy","page":"EDMF Equations","title":"Total energy","text":"fracpartialpartial t hatrho^j e^j = - nabla cdot((hatrho^j e^j + frachatrho^jrho^jp) boldsymbolu^j) - fracprho fracpartialpartial t hatrho^j + RHS\n\nwhich is stabilized with the addition of a 4th-order hyperdiffusion term on total enthalpy:\n\n- nu_h nabla cdot left( hatrho^j nabla^3 left(fracrho^j e^j + prho^j right)right)\n\nThe equation is discretized as\n\nfracpartialpartial t hatrho^j e^j approx\n- D_h left \n    left( hatrho^j e^j + frachatrho^jrho^jp right) \n    left( boldsymbolu_h + I^c(boldsymbolu_v^j) right)\n  right\n- D^c_v left \n    WI^f(Jhatrho^j)   tildeboldsymbolu^j  I^f left(frachatrho^j e^j + frachatrho^jrho^jphatrho^j right)\n  right \n  - fracprho fracpartialpartial t hatrho^j - nu_h hatmathcalD_h( rho mathcalG_h(psi^j) ) + RHS \n\nwhere\n\npsi^j = mathcalP left hatmathcalD_h left( mathcalG_h left(fracrho^j e^j + prho^j right)right) right\n\ntodo: Todo\nNeed to change this to first order upwinding.","category":"section"},{"location":"edmf_equations/#Moisture-tracers","page":"EDMF Equations","title":"Moisture tracers","text":"For a sub-domain moisture scalar q^j, the density-weighted scalar hatrho^j q^j obeys the conservation law\n\nfracpartialpartial t hatrho^j q^j = - nabla cdot(hatrho^j q^j (boldsymbolu^j - w_q^j hatboldsymbolk)) + RHS \n\nwhere hatboldsymbolk is the vertical unit vector and w_q^j is the terminal velocity.\n\nThis is stabilized with the addition of a 4th-order hyperdiffusion term\n\n- nu_q nabla cdot(hatrho^j nabla^3(q^j))\n\nThis is discretized using the following\n\nfracpartialpartial t hatrho^j q^j approx\n- D_h hatrho^j q^j (boldsymbolu_h + I^c(boldsymbolu_v^j))\n- D^c_v left WI^f(Jhatrho^j)  U^fleft( tildeboldsymbolu^j  frachatrho^j q^jhatrho^j right) right\n- nu_chi hatmathcalD_h ( hatrho^j  mathcalG_h (psi^j) ) + sedimentation + RHS\n\nwhere\n\npsi^j = mathcalP left hatmathcalD_h left( mathcalG_h left( frachatrho^j q^jhatrho^j right)right) right\n\nCurrently we use the central reconstruction\n\n- D^c_v left WI^f(Jhatrho^j)  tildeboldsymbolu^j  I^fleft( frachatrho^j q^jhatrho^j right) right\n\ntodo: Todo\nNeed to change this to first order upwinding.\n\ntodo: Todo\nWrite down the discretization for sedimentation. Assume the sedimentation velocity is zero for now.","category":"section"},{"location":"edmf_equations/#Other-tracers","page":"EDMF Equations","title":"Other tracers","text":"For a sub-domain scalar chi^j, the density-weighted scalar hatrho^j chi^j follows the continuity equation\n\nfracpartialpartial t hatrho^j chi^j = - nabla cdot(hatrho^j chi^j boldsymbolu^j) + RHS \n\nThis is stabilized with the addition of a 4th-order hyperdiffusion term\n\n- nu_chi nabla cdot(hatrho^j nabla^3(chi^j))\n\nThis is discretized using the following\n\nfracpartialpartial t hatrho^j chi^j approx\n- D_h hatrho^j chi^j (boldsymbolu_h + I^c(boldsymbolu_v^j))\n- D^c_v left WI^f(Jhatrho^j)  U^fleft( tildeboldsymbolu^j  frachatrho^j chi^jhatrho^j right) right\n- nu_chi hatmathcalD_h ( hatrho^j  mathcalG_h (psi^j) ) + RHS\n\nwhere\n\npsi^j = mathcalP left hatmathcalD_h left( mathcalG_h left( frachatrho^j chi^jhatrho^j right)right) right\n\nCurrently we use the central reconstruction\n\n- D^c_v left WI^f(Jhatrho^j)  tildeboldsymbolu^j  I^fleft( frachatrho^j chi^jhatrho^j right) right\n\ntodo: Todo\nNeed to change this to first order upwinding.","category":"section"},{"location":"gravity_wave/#Gravity-wave-parameterization","page":"Gravity Wave Drag Parameterizations","title":"Gravity wave parameterization","text":"Gravity waves have a great impact on the atmospheric circulation. They are usually generated from topography or convection, propagate upward and alter temperature and winds in the middle atmosphere, and influence tropospheric circulation through downward control. The horizontal wavelength for gravity waves ranges from several kilometers to hundreds of kilometers, which is smaller than typical GCM resolution and needs to be parameterized.\n\nThe gravity wave drag on the wind velocities (overlinevecv=(uv)) are \n\nfracpartial overlinevecv partial t =  - underbracefracpartial overlinevecvwpartial zBig_GW _vecX \n\nwith vecX = (X_lambda X_phi) representing the sub-grid scale zonal and meridional components of the gravity wave drag and is calculated with the parameterization. ","category":"section"},{"location":"gravity_wave/#Non-orographic-gravity-wave","page":"Gravity Wave Drag Parameterizations","title":"Non-orographic gravity wave","text":"The non-orographic gravity wave drag parameterization follows the spectra methods described in [3]. The following assumptions are made for this parameterization to work:\n\nThe wave spectrum consists of independent monochromatic waves, and wave-wave interaction is neglected when propagation and instability is computed.\nThe gravity wave propagates vertically and conservatively to the breaking level and deposits all momentum flux into that level, as opposed to the method using saturation profile described in [4].\nThe wave breaking criterion is derived in a hydrostatic, non-rotating frame. Including non-hydrostatic and rotation is proved to have negligible impacts.\nThe gravity wave is intermittent and the intermittency is computed as the ratio of the total long-term average source to the integral of the source momentum flux spectrum.","category":"section"},{"location":"gravity_wave/#Spectrum-of-the-momentum-flux-sources","page":"Gravity Wave Drag Parameterizations","title":"Spectrum of the momentum flux sources","text":"The source spectrum with respect to phase speed is prescribed in Eq. (17) in [3]. We adapt the equation so that the spectrum writes as a combination of a wide and a narrow band as\n\nB_0(c) = fracF_S0(c)rho_0 = sgn(c-u_0) left( Bm_w expleft -left( fracc-c_0c_w_w right) ln2 right + Bm_n expleft -left( fracc-c_0c_w_n right) ln2 right right)\n\nwhere the subscript 0 denotes values at the source level. c_0 is the phase speed with the maximum flux magnitude Bm. c_w is the half-width at half-maximum of the Gaussian.  _w and _n represent the wide and narrow bands of the spectra.","category":"section"},{"location":"gravity_wave/#Upward-propagation-and-wave-breaking","page":"Gravity Wave Drag Parameterizations","title":"Upward propagation and wave breaking","text":"Waves that are reflected will be removed from the spectrum. A wave that breaks at a level above the source will deposit all its momentum flux into that level and be removed from the spectrum.\n\nThe reflection frequency is defined as\n\nomega_r(z) = (fracN(z)^2 k^2k^2+alpha^2)^12\n\nwhere N(z) is the buoyancy frequency, k is the horizontal wavenumber that corresponds to a wavelength of 300 km, alpha = 1H where H is the scale height. omega_r(z) is used to determine for each monochromatic wave in the spectrum, whether it will be reflected at height z.\n\nThe instability condition is defined as\n\nQ(zc) = fracrho_0rho(z) frac2N(z)B_0(c)kc-u(z)^3\n\nQ(zc) is used to determine whether the monochromatic wave of phase speed c gets unstable at height z. \n\nAt the source level\nif omega=kc-u_0 geq omega_r, this wave would have undergone internal reflection somewhere below and is removed from the spectrum;\nif Q(z_0 c) geq 1, it is also removed because it is not stable at the source level.\nAt the levels above (z_nz_0), omega(z_n)=kc-u(z_n) geq omega_r(z_n) is removed from the spectrum. In the remaining speed, Q(z_nc) geq 1 are breaking between level z_n-1 and z_n, and this portion of momentum flux is all deposited between z_n-1 and z_n, which yields\nX(z_n-12) = fracepsilon rho_0rho(z_n-12)Sigma_j (B_0)j\nwhere epsilon=F_S0rho_0Sigma B_0 is the wave intermittency. In computing the intermittency, F_S0 is the time average total momentum flux and is prescribed as latitude dependent properties.  And we get \nX(z_n-1) = 05*leftX(z_n-32) +X(z_n-12) right\n\nBy applying the above parameterization on zonal and meridional winds, the forcing for the physical wind velocity is computed. We further transform them onto the Covariant vectors and that will be the tendencied added onto the momentum equation.","category":"section"},{"location":"gravity_wave/#Orographic-gravity-wave","page":"Gravity Wave Drag Parameterizations","title":"Orographic gravity wave","text":"The orographic gravity wave drag parameterization follows the methods described in [5]. The momentum drag from sub-grid scale mountains is divided into a non-propagating component and a propagating component. The non-propagating component forces momentum drag within the planetary boundary layer while the propagating component generate a c=0 gravity wave which propagates upwards and deposit momentum flux to the layers where it breaks.","category":"section"},{"location":"gravity_wave/#PBL-top","page":"Gravity Wave Drag Parameterizations","title":"PBL top","text":"There are many ways to determine the PBL top. We implement the following simple criteria to find the PBL top level k as the highest level that satisfies\n\n^c pk ge 05  ^f p0\n\nand\n\n^c T0 + T_boost - ^c Tk  gc_p * ( ^c zk - ^c z0 )\n\nwhere the superscripts f and c represent cell faces and cell centers in the vertical stencils. T_boost = 15 mathrmK is the surface temperature boost to improve PBL height estimate.","category":"section"},{"location":"gravity_wave/#Orographic-information","page":"Gravity Wave Drag Parameterizations","title":"Orographic information","text":"The orographic information needed in generating the base momentum flux for low-level flow encountering the sub-grid scale mountains. We compute the tensor textbfT and the scalar h_max from the Earth elevation data (GFDL codes here).","category":"section"},{"location":"gravity_wave/#Tensor-\\textbf{T}","page":"Gravity Wave Drag Parameterizations","title":"Tensor textbfT","text":"The tensor textbfT, which contains all relevant information including amplitude, variance, orientation, and anisotropy about topography, is computed as\n\ntextbfT = nabla chi (nabla h)^T\n\nwhere h is the earth elevation, and chi = - fracrho N2pi frach(x)x-x int int dx dy is the velocity potential.","category":"section"},{"location":"gravity_wave/#h_max","page":"Gravity Wave Drag Parameterizations","title":"h_max","text":"h_max represents the relation between the local elevation with its surroundings. It is computed as the 4th moments of the local elevation with a certain area.","category":"section"},{"location":"gravity_wave/#Base-flux","page":"Gravity Wave Drag Parameterizations","title":"Base flux","text":"The base momentum flux generated is computed and divided into the propagating and non-propagating components.\n\nLet overlinecdot represents the mean property of the low-level flow which can be obtained as either the average within PBL or the value at the first cell center right above PBL top. Let overlineV = (overlineu overlinev), overlineN, and overlinerho represent the horizontal wind, buoyancy frequency, and density of the low-level flow. overlineN is computed as \n\noverlineN ^2 = fracgoverlineT * left( overlinefracdTdz + fracgc_p right)\n\nThe base flux is computed as the linear drag following\n\ntau = overlinerho overlineN langle textbfT rangle ^T overlineV\n\nwhere langle textbfT rangle = t_11 t_12 t_21 t_22 is the tensor that contains orographic information. In the code, we compute the zonal and meridional components separately as \n\ntau_x = overlinerho overlineN (t_11 overlineu + t_21 overlinev)\n\ntau_y = overlinerho overlineN (t_12 overlineu + t_22 overlinev)\n\nThe base flux is then corrected using Froude number and saturation velocity. Let\n\nV_tau = max(epsilon_0 - overlineV cdot fractautau)\n\nand given the orographic information h_max and h_min, the max and min Froude numbers are computed as\n\nFr_max = h_max fracoverlineNV_tau\n\nFr_min = h_min fracoverlineNV_tau\n\nWe also compute the med Froude number as\n\nFr_med = Fr_crit + Fr_int\n\nwhere Fr_crit = 07 is the critical Froude number for nonlinear flow, Fr_int = 05 is an arbitrary parameter.\n\nThe saturation velocity is computed as\n\nU_sat = sqrtfracoverlinerhorho_0 fracV_pmbtau^3overlineN L_0\n\nwhere rho_0 = 12 mathrmkgm^3 is the arbitrary density scale, and L_0 = 80e3 mathrmm is the arbitrary horizontal length scale. \n\nThe following set of intermediate variables (FrU's) are computed to correct the linear base flux:\n\nFrU_sat = Fr_crit * U_sat\n\nFrU_min = Fr_min * U_sat\n\nFrU_med = Fr_med * U_sat\n\nFrU_max = max(Fr_max * U_sat FrU_min + epsilon_0)\n\nFrU_clp = min(FrU_max max(FrU_min FrU_sat))\n\nFrU_0 = fracU_0V_tauU_sat\n\nand U_0=10 mathrmms is the arbitrary velocity scale.\n\nNow the correct linear drag is computed as \n\ntau_l = fracFrU_max^2+gamma-epsilon - FrU_min^2+gamma-epsilon2+gamma-epsilon\n\nand the propagating and non-propagating parts of the drag are computed as\n\ntau_p = a_0 left fracFrU_clp^2+gamma-epsilon - FrU_min^2+gamma-epsilon2+gamma-epsilon + FrU_sat^beta+2 fracFrU_max^gamma-epsilon-beta - FrU_clp^gamma-epsilon-betagamma-epsilon-beta right\n\ntau_np = a_1 fracU_sat1+beta left fracFrU_max^1+gamma-epsilon - FrU_clp^1+gamma-epsilon1+gamma-epsilon - FrU_sat^beta+1 fracFrU_max^gamma-epsilon-beta - FrU_clp^gamma-epsilon-betagamma-epsilon-beta right\n\nHere, (gamma epsilon beta) = (04 00 05) are arbitrary parameters that describe the mountain shapes.","category":"section"},{"location":"gravity_wave/#Saturation-profiles-for-the-propagating-component","page":"Gravity Wave Drag Parameterizations","title":"Saturation profiles for the propagating component","text":"The vertical profiles of saturated momentum flux tau_sat is computed then so that momentum forcing can be obtained for doverlineVdt = -overlinerho^-1dtau_satdz. This only applies to the propagating part.\n\nSimilar to the base flux calculation but for the 3D fields, we computed N and V_tau at cell faces as\n\n^f Nk^2 = fracg^f Tk * ( ^f overlinefracdTdzk + fracgcp)\n\n^f V_tauk = max(epsilon_0 - Vk cdot fractautau)\n\nwhere epsilon_0 denotes a measure of floating-point precision.\n\nLet L_1 = L_0 * max(05 min(20 10-samp*V_tau*d^2V_tauN^2)) where samp=10 is the correction for coarse sampling of d^2Vdz^2, and\n\n^f d^2V_tauk = - fracd^2 Vdz^2k cdot fractautau\n\nThe saturated velocity U_sat is refined as follows and used to computed the intermediate FrUs\n\nU_sat = min(U_sat sqrtfrac^mathrmf rhorho_0 frac^mathrmf V_pmbtau^3^mathrmfN L_1 )\n\nThe FrU_min and FrU_max are inherited from the base flux calculation. Let's save the source level FrU_sat and FrU_clp into\n\nFrU_sat0 = FrU_sat\n\nFrU_clp0 = FrU_clp\n\nand update FrU_sat and FrU_clp as \n\nFrU_sat = Fr_crit * U_sat\n\nFrU_clp = min(FrU_max max(FrU_min FrU_sat))\n\nThen, the saturated profile of propagating component of the momentum flux is \n\ntau_sat = a_0 left fracFrU_clp^2+gamma-epsilon - FrU_min^2+gamma-epsilon2+gamma-epsilon + FrU_sat^2 FrU_sat0^beta fracFrU_max^gamma-epsilon-beta - FrU_clp0^gamma-epsilon-betagamma-epsilon-beta + FrU_sat^2 fracFrU_clp0^gamma-epsilon - FrU_clp^gamma-epsilongamma-epsilon right\n\nIf the wave does not break and propagates all the way up to the model top, the residual momentum carried by this part will be redistributed throughout the column weighted by pressure to conserve momentum. That is,\n\ntau_satk = tau_satk - tau_satend frac^f p1-^f pk^f p1-^f pend","category":"section"},{"location":"gravity_wave/#Velocity-tendencies-due-to-the-orographic-drag","page":"Gravity Wave Drag Parameterizations","title":"Velocity tendencies due to the orographic drag","text":"","category":"section"},{"location":"gravity_wave/#Propagating-component","page":"Gravity Wave Drag Parameterizations","title":"Propagating component","text":"The forcing from the propagating part on the zonal and meridional wind are\n\n^c left( fracdudt right) _p = - frac1^c rho fractau_xtau_l fracdtau_satdz\n\n^c left( fracdvdt right) _p = - frac1^c rho fractau_ytau_l fracdtau_satdz\n\nHere, (tau_x tau_y tau_l) is computed in the base flux calculation, and tau_sat is calculated in the saturation flux profile. The propagating part functions throughout the entire column.","category":"section"},{"location":"gravity_wave/#Non-propagating-component","page":"Gravity Wave Drag Parameterizations","title":"Non-propagating component","text":"Let's first find the reference level kref below which the non-propagating part functions to decelerate the flow. Let k loops from PBL top upwards, initiate phase = 00 and z_last = ^fzk, if phase leq pi and k is below the top level, update phase and z_last as\n\nphase += fracmax(N_min min(N_max ^fNk))max(vvmin ^f V_tauk) * (^c zk+1 - z_last)\n\nz_last = ^c zk+1\n\nand move one level up. Here, N_min = 07e-2 N_max=17e-2 vvmin = 10; and (^f N ^f V_tau) are computed during the saturation profile calculation. Let kref=k when the loop terminates.\n\nThe drag forcing due to non-propagating component functions from the PBL top to the level of kref and is weighted by pressure. The weights of each level are computed as\n\nweightk = ^c pk - ^f pkref\n\nand the sum of the weights is \n\nwtsum += frac^f pk-1 - ^f pkweightk\n\nFor level k between PBL top and kref, the forcing due to non-propagating component is\n\n^c left( fracdudt k right)_np = g fractau_nptau_l fracweightkwtsum tau_x \n\n^c left( fracdvdt k right)_np = g fractau_nptau_l fracweightkwtsum tau_y \n\nwhere (tau_x tau_y tau_l tau_np) is computed in the base flux calculation.","category":"section"},{"location":"gravity_wave/#Constrain-the-forcings","page":"Gravity Wave Drag Parameterizations","title":"Constrain the forcings","text":"Total drag from both components are\n\n^c left( fracdudt k right)_tau = ^c left( fracdudt k right)_p + ^c left( fracdudt k right)_np\n\n^c left( fracdvdt k right)_tau = ^c left( fracdvdt k right)_p + ^c left( fracdvdt k right)_np\n\nTo avoid instability due to large tendencies from the forcing, let's constrain the forcing magnitude with epsilon_V = 3e-3, and let\n\n^c left( fracdudt k right)_tau = max(-epsilon_V min(epsilon_V ^c left( fracdudt k right)_pmbtau))\n\n^c left( fracdvdt k right)_tau = max(-epsilon_V min(epsilon_V ^c left( fracdvdt k right)_pmbtau))\n\nHere we computed the forcing on the physical velocity (i.e., zonal and meridional wind). They are converted to the Covariant12Vector before being added to Y_t in the codes.","category":"section"},{"location":"microphysics/#Microphysics","page":"Microphysics","title":"Microphysics","text":"","category":"section"},{"location":"microphysics/#Source-terms","page":"Microphysics","title":"Source terms","text":"Sources from cloud microphysics mathcalS represent the transfer of mass   between different water categories such as cloud water, cloud ice or precipitation,   as well as the latent heat release due to phase changes. The model supports three different cloud microphysics and precipitation representations:\n\nequilibrium cloud formation coupled with a 0-moment microphysics scheme,\nnonequilibrium cloud formation coupled with a 1-moment microphysics scheme representing both liquid and ice phase precipitation,\nnonequilibrium cloud formation coupled with a 2-moment microphysics scheme representing liquid phase precipitation.\n\nThe equilibrium 0-moment option does not introduce any new variables to the state vector. The cloud condensate and phase partitioning are diagnosed using saturation adjustment   and the 0-moment microphysics provides a sink on total water due to precipitation. Precipitation is immediately removed from the computational domain. The nonequilibrium 1-moment option expands the state vector by four microphysics tracers:   cloud liquid water, cloud ice, rain and snow (q_liq q_ice q_rai q_sno). The nonequilibrium 2-moment option expands the state vector by four microphysics tracers:   cloud liquid water and droplet number concentration, rain water and drop number concentration:    (q_liq N_liq q_rai N_rai).\n\nAll microphysics mass tracers are part of the working fluid   and are defined as a ratio of the tracer mass over the mass of the working fluid. The different cloud and precipitation source terms are provided by   CloudMicrophysics.jl library   and are defined as the change of mass normalized by the mass of the working fluid. See the CloudMicrophysics.jl docs   for more details.\n\nConsidering the transition from   x rightarrow y where x and y can be any of the microphysics tracers\n\nmathcalS_x rightarrow y = fracfracdm_xdtm_dry + m_vap + m_liq + m_ice + m_rai + m_sno\n\nIf mathcalS_x rightarrow y is a sink of q_tot from the 0-moment scheme   it has a corresponding sink on density and energy:\n\nfracddt rho =\nfracddt rho q_tot =\nrho mathcalS_x rightarrow y\n\nfracddt rho e = rho mathcalS_x rightarrow y (I_y + Phi)\n\nwhere I_y is the internal energy of the y phase.\n\nIn nonequilibrium cloud formation and the 1-moment and 2-moment schemes,   since all microphysics tracers are part of the working fluid,   microphysics sources do not introduce corresponding sources/sinks of   total water, density or total energy.\n\ntodo: Todo\nIn the above derivations we are assuming that the volume of the working fluid is constant (not the pressure).","category":"section"},{"location":"microphysics/#Sedimentation","page":"Microphysics","title":"Sedimentation","text":"All microphysics tracers sediment with a bulk (group) sedimentation velocity   parameterized via CloudMicrophysics.jl. Sedimentation is done implicitly through a first-order upwinding scheme. Because all tracers are part of the working fluid, their sedimentation   results in sedimentation terms for density and total energy.\n\ntodo: Todo\nWe assume that all microphysics tracers are at ambient air temperature. It would be more correct to assume that the microphysics tracers are at wet bulb temperature.","category":"section"},{"location":"microphysics/#Stability-and-positivity","page":"Microphysics","title":"Stability and positivity","text":"Microphysics tracers should remain positive throughout the simulation. The numerics of the model however, may result in errors that lead to the spurious formation   of small negative numbers. Most common causes of those errors are:\n\nspurious oscillations caused by the high order horizontal transport scheme,\ntime integration of microphysics sources at time-step that is longer than the stability limit,\nuse of hyperdiffusion.\n\nOur strategy is to minimize the untoward effects of those errors,   without aiming for strict positivity.","category":"section"},{"location":"microphysics/#Limiters","page":"Microphysics","title":"Limiters","text":"All microphysics source terms are individually limited by the available mass of the source tracer x. We typically set lim_x = fracq_xa  dt where a  1. The limiter is formulated based on the triangle inequality:\n\nlimiter(mathcalS_x rightarrow y lim_x lim_y) = mathcalS_x rightarrow y + lim_x - sqrtmathcalS_x rightarrow y^2 + lim_x^2\n\nIf the source is positive but larger than the available tracer lim_x,   the tendency is smoothly adjusted. If, due to numerics, the source tracer is negative, the resulting tendency switches signs and acts   as a restoring force towards a state where the tracer is positive. This means that instead of x rightarrow y transfer, we now consider y rightarrow x. In such cases we limit the tendency by the available mass of the new source tracer y. All the tendencies passed to the limiter should be positive. In case the numerics switches the sign of the source term itself,   we again treat it as an inverted process y rightarrow x: limiter(mathcalS_x rightarrow y lim_x lim_y) = -limiter(-mathcalS_x rightarrow y lim_y lim_x). Below figure illustrates the behavior of the limiter for positive and negative force   with the x tracer being capped at 5 and the y tracer being capped at 2.\n\ninclude(\"limiter_plots.jl\") # hide\n\n(Image: )","category":"section"},{"location":"microphysics/#Hyperdiffusion","page":"Microphysics","title":"Hyperdiffusion","text":"Hyperdiffusion (nabla^4 operator) is a tendency applied   in order to remove noise buildup at the small scales and improve the model stability. It's more selective than standard diffusion operator, and applies the damping only   at the smallest scales of the simulation without degrading the sharp features   of the modeled tracers.\n\nHyperdiffusion is a higher order derivative operator, and as a result does not guarantee positivity. The user has a choice to opt-in certain microphysics tracers to use hyperdiffusion. By default hyperdiffusion is applied to total water and cloud tracers,   but not precipitating tracers. The magnitude of hyperdiffusion acting on precipitation tracers can be changed by   adjusting the free parameter tracer_hyperdiffusion_factor.","category":"section"},{"location":"microphysics/#Diffusion","page":"Microphysics","title":"Diffusion","text":"ClimaAtmos provides different horizontal and vertical diffusion schemes that can be used   to improve model stability and reduce the negative numbers and spurious oscillations.\n\nHorizontal diffusion tendency is based on either the Smagorinsky-Lilly model   [1] or the Anisotropic Minimum-Dissipation model (AMD) [2]   and is applied explicitly.\n\nVertical diffusion tendency can be based on either of the above models,   or computed as a decaying with height function that is capped at some value above the tropopause. Vertical diffusion can be applied implicitly. When using the decay with height options (VerticalDiffusion or DecayWithHeight),   similar to hyperdiffusion,  diffusion is applied to total water and cloud tracers. The magnitude of diffusion acting on precipitation tracers can be scaled using the   tracer_vertical_diffusion_factor. There is no such scaling applied when using the Smagorinsky-Lilly or AMD models.","category":"section"},{"location":"microphysics/#Moisture-Fixer","page":"Microphysics","title":"Moisture Fixer","text":"The moisture fixer is an optional grid-mean tendency correction that can be enabled for   nonequilibrium moisture models with 1-moment microphysics. When enabled (via the moisture_fixer configuration option), the fixer adjusts small negative   tracer values by transferring mass from water vapor to the affected microphysics tracers   (cloud liquid, cloud ice, rain, and snow). This provides an additional safeguard against numerical errors that may produce negative tracer values,   complementing the limiters and diffusion schemes described above. The fixer operates on the grid-mean tendencies and conserves total water mass.","category":"section"},{"location":"microphysics/#Aerosol-Activation-for-2-Moment-Microphysics","page":"Microphysics","title":"Aerosol Activation for 2-Moment Microphysics","text":"Aerosol activation uses functions from the CloudMicrophysics.jl library, based on the Abdul-Razzak and Ghan (ARG) parameterization. ARG predicts the number of activated cloud droplets assuming a parcel of clear air rising adiabatically. This formulation is traditionally applied only at cloud base, where the maximum supersaturation typically occurs.\n\nTo enable ARG to be used locally (i.e., without explicitly identifying cloud base), CloudMicrophysics.jl implements a modified equation for the maximum supersaturation that accounts for the presence of pre-existing liquid and ice particles. This allows activation to be applied inside clouds. To ensure that activation occurs only where physically appropriate, we apply additional clipping logic:\n\nIf the predicted maximum supersaturation is less than the local supersaturation (i.e., supersaturation is decreasing), aerosol activation is not applied.\nIf the predicted number of activated droplets is less than the existing local cloud droplet number concentration, activation is also suppressed.\n\nThis ensures that droplet activation occurs only in physically meaningful regions—typically near cloud base—even though the activation routine can be applied throughout the domain.","category":"section"},{"location":"single_column_prospect/#Single-Column-Models","page":"Single Column Model","title":"Single Column Models","text":"ClimaAtmos.jl supports several canonical test cases that are run in a single column model designed to verify how well PROSPCT (EDMF) is able to reproduce each of the convective schemes. These cases include variants of bomex, dycoms, rico, soares, gabls, gate,and trmm and can be found in the config/model_configs directory. The purpose of each simulation is summarized in the following table:\n\nAbbreviation Long Name Cloud Regime Reference\nBOMEX Barbados Oceanographic and Meteorological Experiment Marine Cumulus Siebesma et al. (2003)\nDYCOMS Dynamics and Chemistry of Marine Stratocumulus Marine Stratocumulus Stevens et al. (2005), Ackerman et al. (2009)\nRICO Rain in Cumulus over the Ocean Rainy Cumulus Rauber et al. (2007)\nSOARES Shallow Cumulus Convection Shallow Cumulus Soares et al. (2004)\nGABLS GEWEX Atmospheric Boundary Layer Study Dry Convective Boundary Layer Kosović & Curry (2000)\nTRMM Tropical Rainfall Measuring Mission Deep Convection Grabowski et al. (2006)\n\nFor example, to run the BOMEX test case execute the following:\n\njulia --project=.buildkite .buildkite/ci_driver.jl --config_file config/model_configs/prognostic_edmfx_bomex_column.yml --job_id bomex\n\nIt may also be helpful to run in interactive mode to be able to examine the simulation object, debug, and develop the code further. To enter debug mode run julia --project=.buildkite and then in the REPL run:\n\nusing Revise # if you are developing ClimaAtmos\nimport ClimaAtmos as CA\n\n# get the configuration arguments\nsimulation = CA.AtmosSimulation(\"config/model_configs/prognostic_edmfx_bomex_column.yml\")\nsol_res = CA.solve_atmos!(simulation) # run the simulation","category":"section"},{"location":"single_column_prospect/#Externally-Driven-Single-Column-Models","page":"Single Column Model","title":"Externally-Driven Single Column Models","text":"Currently three versions of the externally driven single column model, GCM driven, ReanalysisTimeVarying driven, and ReanalysisMonthlyAveragedDiurnal driven are supported in ClimaAtmos.jl. Externally-driven means that the model is initialized and forced with data coming from a different simulation. This differs from setups like, for example, BOMEX or SOARES which have steady forcing and low domain tops (~4km) or functional forcing, respectively. They have been developed specifically for the purpose of model calibration by recreating statistics that are close to either LES, for the GCM driven case only, or to observations.","category":"section"},{"location":"single_column_prospect/#GCM-Driven-Case","page":"Single Column Model","title":"GCM-Driven Case","text":"For the GCM driven case we can run the experiment using the config file config/model_configs/prognostic_edmfx_gcmdriven_column.yml by running:\n\njulia --project=.buildkite .buildkite/ci_driver.jl --config_file config/model_configs/prognostic_edmfx_gcmdriven_column.yml --job_id gcm_driven_scm\n\nIn the config the following settings are particularly important:\n\ninitial_condition: \"GCM\"\nexternal_forcing: \"GCM\"\nexternal_forcing_file: artifact\"cfsite_gcm_forcing\"/HadGEM2-A_amip.2004-2008.07.nc\ncfsite_number : \"site23\"\nsurface_setup: \"GCM\"\n\nHere we must set all of initial_condition, external_forcing and surface_setup to be GCM as each component requires information from the external file. The external_forcing_file and cfsite_number together determine the temperature, specific humidity, and wind as well as horizontal and vertical advection profiles that drive the simulation, and can be set to a local file path as opposed to using the artifact. Radiation and surface temperature are also specified. Here the forcing file, an example of which is stored in the artifact, contains groups for each cfsite to drive the simulation. See Shen et al. 2022 for more information.","category":"section"},{"location":"single_column_prospect/#Reanalysis-Driven-Case","page":"Single Column Model","title":"Reanalysis-Driven Case","text":"","category":"section"},{"location":"single_column_prospect/#Matched-ERA5-Trajectory","page":"Single Column Model","title":"Matched ERA5 Trajectory","text":"The ReanalysisTimeVarying case extends the GCM driven case by providing support for single-column simulations which resolve the diurnal cycle, can be run at any site globally, and uses reanalysis to drive the simulation, allowing for calibration of EDMF to earth-system observations in the single-column setting. This feature was found to be needed to address biases in calibration arising from correlation between time-of-day and cloud liquid water path over the tropical Pacific. For this simulation we again highlight similar arguments in the config file:\n\ninitial_condition: \"ReanalysisTimeVarying\"\nexternal_forcing: \"ReanalysisTimeVarying\"\nsurface_setup: \"ReanalysisTimeVarying\"\nsurface_temperature: \"ReanalysisTimeVarying\"\nstart_date: \"20070701\"\nsite_latitude: 17.0\nsite_longitude: -149.0\n\nBy this point, the first 4 entries are intuitive. We need to dispatch over each of these methods to setup the forcing for each component of the model. To obtain the observations, now note that instead of directly specifying a file we must specify a start_date, site_latitude, and site_longitude. This is because we now use ClimaArtifacts.jl to store data to ensure reproducibility of our simulation and results. start_date should be in in YYYMMDD format, site_latitude should be in degrees between -90 and 90, and site_longitude should be between -180 and 180. \n\nnote: Note\nDepending on the amount of smoothing and data resolution, points near the boundaries will throw index errors. With default settings, users should stay at least 5 points away from the poles (1° for ERA5 data) for smoothing (4 points) and gradients (one extra point).\n\nThe data is generated by downloading from ECMWF and further documentation for ERA5 data download can be found either directly on the ECMWF page and ClimaArtifacts.jl. Note that the profiles, surface temperature, and surface fluxes cannot be obtained from a single request and so together we need 3 files for all the data. We include a script at src/utils/era5_observations_to_forcing_file.jl which extracts the profiles and computes the tendencies needed for the simulation from the raw ERA5 reanalysis files. We store the observations directly into an artifact era5_hourly_atmos_processed to eliminate the need to reprocess specific sites and locations. This setup means that users are free to choose sites globally at any time at which ERA5 data is available. Unfortunately, global hourly renanalysis is too large to store in an artifact and so we have currently only provided support for the first 5 days of July 2007 in the tropical Pacific, stored in era5_hourly_atmos_raw, only available on the clima and Caltech HPC servers. The test case can be run using: \n\njulia --project=.buildkite .buildkite/ci_driver.jl --config_file config/model_configs/prognostic_edmfx_tv_era5driven_column.yml --job_id era5driven","category":"section"},{"location":"single_column_prospect/#Monthly-Averaged-Forcing","page":"Single Column Model","title":"Monthly Averaged Forcing","text":"As the matched ERA5 trajectory is data intensive, requiring downloads for each day, we have also implemented an external forcing dispatch to repeat a specific day of data indefinitely. This setup is ideal for use with monthly averaged ERA5 data by hour of day and can be used to calibrate to monthly statistics. The setup is similar, except we change the flag for external_forcing to indicate that we want to repeat data: \n\ninitial_condition: \"ReanalysisTimeVarying\"\nexternal_forcing: \"ReanalysisMonthlyAveragedDiurnal\"\nsurface_setup: \"ReanalysisTimeVarying\"\nsurface_temperature: \"ReanalysisTimeVarying\"\nstart_date: \"20070701\"\nsite_latitude: 17.0\nsite_longitude: -149.0\n\njulia --project=.buildkite .buildkite/ci_driver.jl --config_file config/model_configs/prognostic_edmfx_diurnal_scm_imp.yml --job_id bomex","category":"section"},{"location":"single_column_prospect/#Running-the-Reanalysis-driven-cases-at-different-times-and-locations","page":"Single Column Model","title":"Running the Reanalysis-driven cases at different times and locations","text":"You need 3 separate files with specific variables and naming convention for the data processing script to work.\n\nHourly profiles with variables, following ERA5 naming convention, including t, q, u, v, w, z, clwc, ciwc. This file should be stored in the appropriate artifacts directory, named \"forcing_and_cloud_hourly_profiles_$(start_date).nc\" for ReanalysisTimeVarying and monthly_diurnal_profiles_$start_date).nc for ReanalysisMonthlyAveragedDiurnal where start_date should specify the date data starts on formatted YYYYMMDD. We require clwc and ciwc profiles because these are typical targets for calibration but are not needed to run the simulation directly.\nInstantaneous variables, including surface temperature ts which should be stored in \"hourly_inst_$(start_date).nc\" for ReanalysisTimeVarying and monthly_diurnal_inst for ReanalysisMonthlyAveragedDiurnal.\nAccumulated variables, including surface sensible and latent heat fluxes, hfls and hfss, which should be stored in \"hourly_accum_$(start_date).nc\" for ReanalysisTimeVarying and monthly_diurnal_accum for ReanalysisMonthlyAveragedDiurnal. These need to be divided by the appropriate time resolution, which for hourly data is 3600 and for daily and monthly data is 86400 (not a typo see here).","category":"section"},{"location":"single_column_prospect/#On-HPC/Clima","page":"Single Column Model","title":"On HPC/Clima","text":"To run locations already in the artifact, e.g., sites in the tropical Pacific in the first 5 days of July 2007 the config file will work out of the box. To run other locations or times please follow the steps for local.","category":"section"},{"location":"single_column_prospect/#On-local","page":"Single Column Model","title":"On local","text":"To run the simulation on a local machine you will need to first download the reanalysis data from ECMWF, ensuring that you have all the required variables. This will be stored in 3 separate files which should be all placed in the same directory. The user edit .julia/artifacts/Overrides.toml to point the era5_hourly_atmos_raw artifact point to the folder where the data is stored. For the raw data and location for processed files you'll need to specify the path where the data is stored and where to store the files as follows:\n\n8234def2ead82e385a330a48ed2f0c030e434065 = \"/some/random/path/raw_data_dir\" # for raw data\na1a465e8d237d78bef1e6d346054da395787a9f9 = \"/some/random/path/processed_files\" # for storing\n\nGood luck! :wink:","category":"section"},{"location":"parameters/#Overview","page":"Parameters","title":"Overview","text":"Parameters in ClimaAtmos.jl are handled by ClimaParams.jl. The repository stores all default values of parameters used in ClimaAtmos and has various utilities for handling parameters. It allows for easy parameter overriding without needing to change the source code directly. For more information, see the docs.","category":"section"},{"location":"parameters/#How-to-add-your-own-parameters-to-ClimaAtmos:","page":"Parameters","title":"How to add your own parameters to ClimaAtmos:","text":"First, create a TOML file with the parameters you want to add/override. Here is the basic format for a single parameter:\n\n[descriptive name]\nvalue = <value>\ntype = \"<type>\"\n\nThe possible types are: bool, float, integer, or string.","category":"section"},{"location":"parameters/#Basic-example-for-gravitational-acceleration:","page":"Parameters","title":"Basic example for gravitational acceleration:","text":"[gravitational_acceleration]\nvalue = 9.81\ntype = \"float\"\n\nFor more info on formatting the TOML, see here.\n\nOnce you have created your parameter file (parameters.toml), you must create a separate YAML configuration file (config.yaml). In the config file, enter:\n\ntoml: parameters.toml\n\nIn order to run the model, type: julia --project=.buildkite --config_file config.yaml. Note that the --config_file argument can take several config files, so if you have a separate config file you would like to use, you can simply add it to the end of the command line arguments. Alternatively, you can just add your TOML config to the existing config file.","category":"section"},{"location":"available_diagnostics/#Available-diagnostic-variables","page":"Available Diagnostics","title":"Available diagnostic variables","text":"Autogenerate table of available diagnostics:\n\ninclude(\"make_diagnostic_table.jl\")","category":"section"},{"location":"config/#Creating-custom-configurations","page":"Configuration","title":"Creating custom configurations","text":"To create a custom configuration, first make a .yml file. In the file, you can set configuration arguments as key: value pairs to override the default config. YAML parsing is fairly forgiving – values will generally be parsed to the correct type. The only exception is true/false strings. These need quotes around them, or they will be parsed to Bools.\n\nTo start the model with a custom configuration, run:\n\njulia --project=.buildkite .buildkite/ci_driver.jl --config_file <yaml>","category":"section"},{"location":"config/#Example","page":"Configuration","title":"Example","text":"Below is the default Bomex configuration:\n\ninitial_condition: \"Bomex\"\nsubsidence: \"Bomex\"\nscm_coriolis: \"Bomex\"\nls_adv: \"Bomex\"\nsurface_setup: \"Bomex\"\nturbconv: \"prognostic_edmfx\"\nedmfx_upwinding: first_order\nedmfx_entr_model: \"Generalized\"\nedmfx_detr_model: \"Generalized\"\nedmfx_sgs_mass_flux: true\nedmfx_sgs_diffusive_flux: true\nedmfx_nh_pressure: true\nprognostic_tke: false\nmoist: \"equil\"\nconfig: \"box\"\nhyperdiff: true\nx_max: 1e8\ny_max: 1e8\nz_max: 3e3\nx_elem: 2\ny_elem: 2\nz_elem: 60\nz_stretch: false\nperturb_initstate: false\ndt: \"5secs\"\nt_end: \"6hours\"\ndt_save_state_to_disk: \"10mins\"\ntoml: [toml/prognostic_edmfx.toml]\n\nKeys can also point to artifacts. As artifacts are folders, we specify both the artifact name, as we would from the REPL, and file to read from, separated by a /. For example, to drive a single column model with an external forcing file from GCM output, we include the following lines in the configuration:\n\ninsolation: \"gcmdriven\"\nexternal_forcing_file: artifact\"cfsite_gcm_forcing\"/HadGEM2-A_amip.2004-2008.07.nc\n\nTo learn more about artifacts and how they're used in CliMA, visit ClimaArtifacts.jl.\n\nTo add a new configuration argument/key, open .buildkite/default_config.yml. Add an entry with the following format:\n\n<argument_name>:\n    value: <argument_value>\n    help: <help string>\n\nThe help field is optional if you don't plan on making a permanent change to the configuration argument.\n\nSee below for the full list of configuration arguments.","category":"section"},{"location":"config/#Common-Configurations","page":"Configuration","title":"Common Configurations","text":"ClimaAtmos provides a set of common numerical configurations that can be used as building blocks for different types of simulations. These configurations are located in config/common_configs/ and contain standardized settings for grid resolution, time stepping, and numerical schemes.","category":"section"},{"location":"config/#Available-Common-Configurations","page":"Configuration","title":"Available Common Configurations","text":"","category":"section"},{"location":"config/#Column-Configurations","page":"Configuration","title":"Column Configurations","text":"numerics_column_ze63.yml: Single column configuration with 63 vertical levels","category":"section"},{"location":"config/#Sphere-Configurations","page":"Configuration","title":"Sphere Configurations","text":"numerics_sphere_he6ze10.yml: Spherical configuration with 6 horizontal elements (550km), 10 vertical levels, 30km domain top, no sponge, explicit vertical diffusion\nnumerics_sphere_he6ze31.yml: Spherical configuration with 6 horizontal elements (550km) , 31 vertical levels, 60km domain top, rayleigh and viscous sponges, implicit vertical diffusion\nnumerics_sphere_he16ze63.yml: Spherical configuration with 16 horizontal elements (206km), 63 vertical levels, 60km domain top, rayleigh and viscous sponges, implicit vertical diffusion\nnumerics_sphere_he30ze43.yml: Spherical configuration with 30 horizontal elements (110km), 43 vertical levels, 30km domain top, no sponge, explicit vertical diffusion\nnumerics_sphere_he30ze63.yml: Spherical configuration with 30 horizontal elements (110km), 63 vertical levels, 60km domain top, rayleigh and viscous sponges, implicit vertical diffusion","category":"section"},{"location":"config/#Using-Common-Configurations","page":"Configuration","title":"Using Common Configurations","text":"Common configurations are designed to be used in combination with model-specific configurations. In the CI pipeline and when running simulations, you can specify multiple configuration files:\n\njulia --project=.buildkite .buildkite/ci_driver.jl \\\n  --config_file config/common_configs/numerics_sphere_he16ze63.yml \\\n  --config_file config/model_configs/your_model_config.yml\n\nThe common configuration provides the numerical setup (grid, time stepping, etc.), while the model configuration provides the physical setup (physics schemes, initial conditions, etc.). The model configuration will override any conflicting settings from the common configuration. Please modify them only if you are certain of the implications.","category":"section"},{"location":"config/#Default-Configuration","page":"Configuration","title":"Default Configuration","text":"Argument Type Description\ndz_bottom Float64 Model bottom grid depth. Default: 500m\nz_stretch Bool Stretch grid in z-direction. [`true` (default), `false`]\nh_elem Int64 number of elements per edge on a cubed sphere\nx_elem Int64 number of horizontal elements in the x-direction\nx_max Float64 Model domain size, x direction. Default: 300km\ny_elem Int64 number of horizontal elements in the y-direction\ny_max Float64 Model domain size, y direction. Default: 300km\nz_elem Int64 number of vertical elements\nz_max Float64 Model top height. Default: 30km\nvorticity_hyperdiffusion_coefficient Float64 Hyperdiffusion coefficient for vorticity (m s-1)\nscalar_hyperdiffusion_coefficient Float64 Hyperdiffusion coefficient for scalar (m s-1)\ntopography String Define the surface elevation profile [`NoWarp` (default), `Earth`, `DCMIP200`, `Hughes2023`, `Agnesi`, `Schar`, `Cosine2D`, `Cosine3D`]\nmesh_warp_type String Sets the interior mesh warp method [`Linear`, `SLEVE`]\nsleve_eta Float64 If SLEVE coordinates are chosen, sets the `ηₕ` parameter (if z/z_top > ηₕ, no warping is applied)\nsleve_s Float64 If SLEVE coordinates are chosen, sets `s`, the warping decay scale parameter\ntopo_smoothing Bool Choose whether to order-2 smoothing on the LGL mesh\ntopography_damping_factor Int64 Factor by which smallest resolved length-scale is to be damped\nuse_newton_rtol Bool Whether to check if the current iteration of Newton's method has an error within a relative tolerance, instead of always taking the maximum number of iterations (only for ClimaTimeSteppers.jl)\nnewton_rtol Float64 Relative tolerance of Newton's method (only for ClimaTimeSteppers.jl; only used when `use_newton_rtol` is `true`)\nsurface_thermo_state_type String Surface thermo state type [`GCMSurfaceThermoState` (default), `PrescribedThermoState`]\nsplit_ode Bool Use split of ODE problem. Examples: [`true` (implicit, default), `false` (explicit)]\nuse_krylov_method Bool Whether to use a Krylov method to solve the linear system in Newton's method (only for ClimaTimeSteppers.jl)\nuse_dynamic_krylov_rtol Bool Whether to use Eisenstat-Walker forcing instead of a constant relative tolerance in the Krylov method (only for ClimaTimeSteppers.jl)\nmax_newton_iters_ode Int64 Maximum number of Newton's method iterations (only for ODE algorithms that use Newton's method)\node_algo String ODE algorithm [`ARS343` (default), `SSP333`, `IMKG343a`, etc.]\nkrylov_rtol Float64 Relative tolerance of the Krylov method (only for ClimaTimeSteppers.jl; only used if `use_krylov_method` is `true`)\neisenstat_walker_forcing_alpha Float64 Value of alpha to use for Eisenstat-Walker forcing (only for ClimaTimeSteppers.jl; only used if `use_krylov_method` and `use_dynamic_krylov_rtol` are `true`)\njvp_step_adjustment Float64 Amount by which the step size of the forward difference approximation of the Jacobian-vector product in the Krylov method should be scaled (only used if `use_krylov_method` is `true`)\nuse_dense_jacobian Bool Whether to use a dense Jacobian matrix that is computed using forward-mode automatic differentiation and inverted using LU factorization [`true`, `false` (default)]\nuse_auto_jacobian Bool Whether to populate the entries of the sparse Jacobian matrix using forward-mode automatic differentiation with sparse matrix coloring (only used when `use_dense_jacobian` is `false`) [`true`, `false` (default)]\nauto_jacobian_padding_bands Nothing Target number of bands to add in every block of the sparse Jacobian matrix, eliminating errors from Jacobian entries that lie outside of the default sparsity pattern; when unspecified, each block gets a predetermined number of padding bands based on the typical magnitudes of its entries (only used when `use_auto_jacobian` is `true`)\nupdate_jacobian_every String Frequency at which the Jacobian matrix should be updated (once per timestep, once per timestepper stage, or once per linear solve) [`dt`, `stage`, `solve` (default)]\ndebug_jacobian Bool Whether to print summary information about the Jacobian matrix, including comparisons of different algorithms evaluated on the first column of the final state against the exact Jacobian [`true`, `false` (default)]\nrad Nothing Radiation model [`nothing` (default), `gray`, `clearsky`, `allsky`, `allskywithclear`]\nidealized_h2o Bool Use idealized H2O in radiation model [`false` (default), `true`]\ndt_rad String Time between calling radiation callback for sphere configurations\nidealized_clouds Bool Use idealized clouds in radiation model [`false` (default), `true`]\nprescribe_clouds_in_radiation Bool Use prescribed clouds in radiation model. Clouds are read from ERA5 data and updated every time radiation is called. The year 2010 is used and continuously repeated. This mode only affect radiation and is only relevant for the RRTGMP mode. [`false` (default), `true`]\ninsolation String Insolation used in radiation model [`idealized` (default), `timevarying`, `rcemipii`]\nadd_isothermal_boundary_layer Bool Add an isothermal boundary layer above the domain top for radiation [`false`, `true` (default)]\naerosol_radiation Bool Use aerosols in radiation [`false` (default)]\ndt_cloud_fraction String Time between calling cloud fraction update\nconfig String Spatial configuration [`sphere` (default), `column`, `box`, `plane`]\nFLOAT_TYPE String Float type\ndt String Simulation time step. Examples: [`10secs`, `1hours`]\nt_start String Simulation start time. This is typically useful in the context of manually restarting a simulation (e.g., but reinitializing the initial state). It is overwritten when the simulation is restarted with the checkpointing system. Examples: [`0secs`, `40secs`]\nt_end String Simulation end time. Examples: [`1200days`, `40secs`]\noutput_dir Nothing Output directory\noutput_dir_style String What to do when `output_dir` already exists. With `RemovePreexisting`, `output_dir` is overwritten with a new one. With `ActiveLink`, `output_dir` is treated as a base folder and numbered subfolders are created inside. A new subfolder is created every time a simulation is run, with `output_dir/output_active` pointing to the most recent results. Check out ClimaUtilities.OutputPathGenerator for more information. [`ActiveLink` (default), `RemovePreexisting`]\ndevice String Device type to use [`auto` (default) `CPUSingleThreaded`, `CPUMultiThreaded`, `CUDADevice`]\nreference_job_id Nothing Identifier of job to use as the \"reference\" solution in the quicklook plot; the current job's results get compared to the results of the quicklook job on the main branch\nvert_diff String Vertical diffusion [`false` (default), `VerticalDiffusion`, `true` (defaults to `VerticalDiffusion`), `DecayWithHeightDiffusion`]\nhyperdiff String Hyperdiffusion. Use `CAM_SE` for sensible default values and ClimaHyperdiffusion for user control. [`CAM_SE` (default), `ClimaHyperdiffusion` (or `true`), `none` (or `false`)]\namd_les Bool AMD LES closure [`true`, `false` (default)]\nc_amd Float64 Model coefficient for AMD-LES closure (TODO: Move to parameters.toml)\nconstant_horizontal_diffusion Bool Constant horizontal diffusion closure [`true`, `false` (default)]\nsmagorinsky_lilly Nothing Smagorinsky-Lilly diffusive closure [`nothing` (default), `UVW`, `UV`, `W`, `UV_W_decoupled`]\ntracer_nonnegativity_method Nothing Optionally constrain microphysical condensate tracers (q_liq, q_rai, q_ice, q_sno) to be nonnegative. Options:\\n- `elementwise_constraint`: Enforce nonnegativity by instantaneously redistributing tracer mass within an element\\n- `vapor_constraint`: Enforce nonnegativity by instantaneously redistributing tracer mass between vapor (q_tot) and each tracer\\n- `vapor_tendency`: Weakly enforce nonnegativity by applying a tendency to each tracer to redistribute tracer mass between vapor (q_tot) and each tracer\\n- `\\~` (default): Do not enforce nonnegativity\\nNote: append `_qtot` to the method name to enforce nonnegativity of q_tot as well.\\n\nbubble Bool Enable bubble correction for more accurate surface areas\nstart_date String Start date and time of the simulation. Specified as either yyyymmdd (defaults to midnight) or yyyymmdd-HHMM. Examples: [`20100101`, `20100101-0000`]\nera5_initial_condition_dir Nothing Directory containing ERA5 initial condition files. Filenames inferred from start_date [none (default)]. Generated with `https://github.com/CliMA/WeatherQuest`.\nforcing Nothing Forcing [`nothing` (default), `held_suarez`]\ntest_dycore_consistency Bool Test dycore consistency [`false` (default), `true`]\ndt_save_state_to_disk String Time between saving the state to disk. Examples: [`10secs`, `1hours`, `1months`, `Inf` (do not save, default)]\nmoist String Moisture model [`dry` (default), `equil`, `nonequil`]\ndivergence_damping_factor Float64 Divergence damping factor\nrayleigh_sponge Bool Rayleigh sponge [`true`, `false` (default)]\ndisable_surface_flux_tendency Bool (Bool) Whether to disable surface flux tendencies of momentum, energy, and tracers [`true`, `false` (default)]. When this flag is true, the surface flux tendency is not applied, no matter how surface conditions are computed.\nsurface_setup String Surface flux scheme [`DefaultExchangeCoefficients` (default), `DefaultMoninObukhov`, `GCM`, `Reanalysis`, `ReanalysisTimeVarying`]\nsurface_temperature String Prescribed surface temperature functional form ['ZonallySymmetric' (default), 'RCEMIPII', `Reanalysis`, `ReanalysisTimeVarying`]\ninitial_condition String Initial condition [`DryBaroclinicWave`, `MoistBaroclinicWave`, `ConstantBuoyancyFrequencyProfile`, `DecayingProfile` (default), `IsothermalProfile`, `Bomex`, `DryDensityCurrentProfile`, `RisingThermalBubbleProfile`, `ISDAC`, `GCM`, `Reanalysis`, `ReanalysisTimeVarying`], or a file path for a NetCDF file (read documentation about requirements).\nperturb_initstate Bool Add a perturbation to the initial condition [`false`, `true` (default)]\napply_limiter Bool Apply a horizontal limiter to every tracer [`false` (default), `true`]\nprecip_model Nothing Precipitation model [`nothing` (default), `0M`, `1M`]\ncloud_model String Cloud model [`grid_scale`, `quadrature` (default), `MLCloud`]\ncloud_nn_architecture String Cloud neural network architecture to use when `cloud_model` is set to `MLCloud` [`arch_2layers_8nodes.jld2` (default), etc.]\nimplicit_noneq_cloud_formation Bool Whether to treat the nonequilibrium cloud condensate tendency implicitly [`true`, `false` (default)]\nperf_summary Bool Flag for collecting performance summary information\nviscous_sponge Bool Viscous sponge [`true`, `false` (default)]\ntracer_upwinding String Tracer upwinding mode [`none`, `first_order` , `third_order`, `vanleer_limiter` (default)]\nenergy_q_tot_upwinding String Energy upwinding mode [`none`, `first_order` , `third_order`, `vanleer_limiter` (default)]\norographic_gravity_wave Nothing Orographic drag on horizontal mean flow [`nothing` (default), `gfdl_restart`, `raw_topo`]\nnon_orographic_gravity_wave Bool Apply parameterization for convective gravity wave forcing on horizontal mean flow [`false` (default), `true`]\ndt_nogw String Time between calling non-orographic gravity wave update\nnh_poly Int64 Horizontal polynomial degree. Note: The number of quadrature points in 1D within each horizontal element is then Nq = <–nh_poly> + 1\nreproducibility_test Bool (Bool) perform reproducibility test\ncheck_conservation Bool Check conservation of mass and energy [`false` (default), `true`]\ncheck_steady_state Bool Compare steady-state velocity to analytic solution; only available for certain choices of `topography` [`false` (default), `true`]\nls_adv Nothing Large-scale advection [`nothing` (default), `Bomex`, `Rico`]\nexternal_forcing Nothing External forcing for single column experiments [`nothing` (default), `GCM`, `Reanalysis`, `ReanalysisTimeVarying`, `ReanalysisMonthlyAveragedDiurnal`]\nexternal_forcing_file Nothing External forcing file containing large-scale forcings, initial conditions, and boundary conditions. Used for GCM-driven SCM and ISDAC setup [`nothing` (default), `path/to/file`]\ncfsite_number String cfsite identifier for single column forcing from  `external_forcing_file`, specified as siteN. For site details see Shen et al. 2022 `https://doi.org/10.1029/2021MS002631`. [`site23` (default), `siteN`]\nsite_latitude Float64 Site latitude for single column model. Used for externally driven time varying forcing model to generate the forcing file. Artifact support is currently for eastern Pacific region in July 2007 only. [`17.0` (default)]\nsite_longitude Float64 Site longitude for single column model. Used for externally driven time varying forcing model to generate the forcing file. Artifact support is currently for eastern Pacific region in July 2007 only. [`-149.0` (default)]\nera5_diurnal_warming Nothing Applies a warming scenario by adding a constant temperature offset (in Kelvin). Supported only by the `ReanalysisMonthlyAveragedDiurnal` forcing model. This affects the target surface temperature for the entire simulation, the initial atmospheric temperature profile, and the relaxation temperature profile above `gcmdriven_relaxation_minimum_height`. Specific humidity is increased to hold relative humidity constant in the initial and relaxation profiles.\nsubsidence Nothing Subsidence [`nothing` (default), `Bomex`, `Rico`, `DYCOMS`, `ISDAC`]\ntoml Vector{Any} TOML file(s) used to override model parameters\nstrict_params Bool Raise an error if any overridden parameters are unused.\nprognostic_tke Bool A flag for prognostic TKE [`false` (default), `true`]\nprognostic_surface String Determines if surface temperature is prognostic [`false` (default), , `true`, `SlabOceanSST`, `PrescribedSST`]\nalbedo_model String Variable surface albedo [`ConstantAlbedo` (default), `RegressionFunctionAlbedo`, `CouplerAlbedo`]\nimplicit_diffusion Bool Whether to treat the vertical diffusion tendency implicitly [`false` (default), `true`]\napproximate_linear_solve_iters Int64 Number of iterations for the approximate linear solve (used when `implicit_diffusion` is true)\noutput_default_diagnostics Bool Output the default diagnostics associated to the selected atmospheric model\nenable_diagnostics Bool Set to false to fully disable the diagnostics\nnetcdf_output_at_levels Bool Do not perform any vertical interpolation in the output NetCDF files. Instead, interpolate horizontally and output the level.\nnetcdf_interpolation_num_points Nothing Override the number of interpolation point for the NetCDF output. This configuration has to be a list of integers, e.g. [180, 90, 10].\ncheck_nan_every Int64 Check if the state contains NaNs every this number of iterations\nlog_progress Bool Log simulation progress, including wall-time estimates\ndeep_atmosphere Bool If true, use deep atmosphere equations and metric terms, otherwise assume columns are cylindrical (shallow atmosphere) [`true` (default), `false`]\nrestart_file Nothing Path to HDF5 file to use as simulation starting point. Note that the simulation can only be restarted in a reproducible way when `reproducible_restart` is true.\ndetect_restart_file Bool When true, try finding a restart file and use it to restart the simulation. Only works with ActiveLink.\nreproducible_restart Bool If true, the simulation is reproducible when restarting from a restart file. Disable this option when running production runs.\nprescribed_aerosols Vector{Any} Which aerosols to add. List of keys from the data file (e.g., CB1, CB2).\ntime_varying_trace_gases Vector{Any} Trace gases that vary in time, e.g. [\"CO2\", \"O3\"]. Currently, only \"CO2\" and \"O3\" are supported. All other trace gases set fixed to default values from ClimaParams.\ncall_cloud_diagnostics_per_stage Bool A temporary Bool for calling cloud diagnostics every stage\nturbconv Nothing Turbulence convection scheme [`nothing` (default), 'prognostic_edmfx', 'diagnostic_edmfx']\nadvection_test Bool Switches off all grid-scale and subgrid-scale momentum tendencies [`false` (default), `true`]\nedmfx_scale_blending String Method for blending physical scales in EDMFX mixing length calculation. [`SmoothMinimum` (default), `HardMinimum`]\nimplicit_sgs_advection Bool Whether to treat the subgrid-scale vertical advection tendency implicitly [`false` (default), `true`]\nimplicit_sgs_entr_detr Bool Whether to treat the subgrid-scale entrainment and detrainment tendency implicitly [`false` (default), `true`]. Setting it to true only works if implicit_sgs_advection is set to true.\nimplicit_sgs_nh_pressure Bool Whether to treat the subgrid-scale nonhydrostatic pressure closure implicitly. Setting it to true only works if\\n`implicit_sgs_advection` is set to true. This flag only controls whether the drag term in the pressure closure is treated implicitly.\\nThe buoyancy term is always treated implicitly. [`false` (default), `true`]\nimplicit_sgs_vertdiff Bool Whether to treat the subgrid-scale vertical diffusion tendency implicitly [`false` (default), `true`]. Setting it to true only works if implicit_sgs_advection is set to true.\nimplicit_sgs_mass_flux Bool Whether to treat the subgrid-scale mass flux tendency implicitly or explicitly in grid-mean equations. Currently updraft only with Jacobian terms 0. [`false` (default), `true`]. Setting it to true only works if both implicit_sgs_advection and implicit_diffusion are set to true.\nscm_coriolis Nothing SCM Coriolis [`nothing` (default), `Bomex`, `Rico`,`DYCOMS_RF01`,`DYCOMS_RF02`,`GABLS`]\nedmfx_filter Bool If set to true, it switches on the relaxation of negative velocity in EDMFX.  [`true`, `false` (default)]\nedmfx_nh_pressure Bool If set to true, it switches on EDMFX pressure drag closure.  For prognostic EDMF, this only controls the drag term\\nin the pressure closure. The buoyancy term is always applied. [`true`, `false` (default)]\nedmfx_vertical_diffusion Bool If set to true, it switches on vertical diffusion of prognostic EDMFX updrafts. [`true`, `false` (default)]\nedmfx_entr_model Nothing EDMFX entrainment closure.  [`nothing` (default), `PiGroups`, `Generalized`]\nedmfx_detr_model Nothing EDMFX detrainment closure.  [`nothing` (default), `PiGroups`, `Generalized`]\nedmfx_mse_q_tot_upwinding String EDMFX upwinding mode [`none`, `first_order` (default), `third_order`]\nedmfx_tracer_upwinding String EDMFX tracer upwinding mode [`none`, `first_order` (default)]\nedmfx_sgsflux_upwinding String EDMFX SGS mass flux upwinding mode [`none` (default), `first_order`, `third_order`]\nedmfx_sgs_mass_flux Bool If set to true, it switches on EDMFX SGS mass flux.  [`true`, `false` (default)]\nedmfx_sgs_diffusive_flux Bool If set to true, it switches on EDMFX SGS diffusive flux.  [`true`, `false` (default)]\nupdraft_number Int64 Sets the number of updrafts for the EDMF scheme\nradiation_reset_rng_seed Bool Reset the RNG seed before calling RRTGMP to a known value (the timestep number). When modeling cloud optics, RRTGMP uses a random number generator. Resetting the seed every time RRTGMP is called to a deterministic value ensures that the simulation is fully reproducible and can be restarted in a reproducible way. Disable this option when running production runs. Please note that this flag is only used for `AllSkyRadiation` and `AllSkyRadiationWithClearSkyDiagnostics` radiation modes.\nlog_to_file Bool Log to stdout and file simultaneously. The log file is saved within the output directory\nuse_itime Bool If set to true, ITime (integer time) is used. This should be set to true when precision with time is necessary as floating point time may encounter floating point errors. When converting an ITime back to a float, the float will be Float64. See the examples below where there will be a difference in ITime and Float64:\\n1. Surface conditions that explicitly depend on time (e.g. TRMM_LBA),\\n2. Time dependent forcing/tendencies use time rounded to the nearest unit of time for dt\nprescribed_flow Nothing Prescribe a flow field [`nothing` (default), `ShipwayHill2012`]","category":"section"},{"location":"longruns/#Buildkite-longrun-jobs","page":"Longruns","title":"Buildkite longrun jobs","text":"Here is a brief description of the buildkite longrun jobs.\n\nlongrun_hydrostatic_balance\n\nSolid body rotation. Test if the dry dycore can maintain the no flow steady state.\n\nlongrun_dry_baroclinic_wave\n\nDry baroclinic wave. Test the dry dycore initial value problem.\n\nlongrun_dry_baroclinic_wave_he60\n\nDry baroclinic wave with a higher resolution.\n\nlongrun_moist_baroclinic_wave\n\nMoist baroclinic wave. Test the moist dycore initial value problem.\n\nlongrun_moist_baroclinic_wave_he60\n\nMoist baroclinic wave with a higher resolution.\n\nlongrun_dry_held_suarez\n\nDry Held Suarez. Test the dry dycore with an equilibrium state with sources and sinks.\n\nlongrun_moist_held_suarez\n\nMoist Held Suarez. Test the moist dycore with an equilibrium state with sources and sinks.\n\nlongrun_aquaplanet_allsky_0M\n\nAquaplanet with idealized insolation, all-sky radiation, and 0-moment microphysics.\nUse this job to test new physical components.\n\nlongrun_aquaplanet_allsky_diagedmf_0M\n\nAquaplanet with idealized insolation, all-sky radiation, diagnostic edmf\nand 0-moment microphysics.\n\nlongrun_aquaplanet_allsky_progedmf_0M\n\nAquaplanet with idealized insolation, all-sky radiation, prognostic edmf with 0-moment microphysics.\n\nlongrun_aquaplanet_allsky_tvinsol_0M_slabocean\n\nAquaplanet with slab ocean with time-varying insolation, clear-sky radiation,\nand 0-moment microphysics.\nTest if the coupled system conserves energy and water.\nTest if the time-varying insolation yields reasonable results.\n\nlongrun_aquaplanet_allsky_0M_earth\n\nAquaplanet with idealized insolation, all-sky radiation, 0-moment microphysics, and\nEarth topography. Use this job to test topography related features.\n\nlongrun_aquaplanet_allsky_1M\n\nAquaplanet with idealized insolation, all-sky radiation, 1-moment microphysics.\nUse this job to test 1-moment microphysics related features.\n\nlongrun_aquaplanet_dyamond\n\nAquaplanet setup for DYAMOND (global high-resolution simulation). This job includes\nall the atmosphere components required for DYAMOND. It will be updated whenever new components are ready.\n\namip_target_diagedmf\n\nAquaplanet setup for AMIP (atmosphere-land simulation). This job includes all the\nworking atmosphere components required for AMIP. It will be updated whenever new components are ready.\n\namip_target_edonly\n\nAquaplanet setup for AMIP (atmosphere-land simulation) without convection. This job includes all the\nworking atmosphere components required for AMIP without convection. It will be updated whenever new components are ready.","category":"section"},{"location":"diagnostics/#Computing-and-saving-diagnostics","page":"Diagnostics","title":"Computing and saving diagnostics","text":"","category":"section"},{"location":"diagnostics/#I-want-to-compute-and-output-a-diagnostic-variable","page":"Diagnostics","title":"I want to compute and output a diagnostic variable","text":"","category":"section"},{"location":"diagnostics/#From-a-YAML-file","page":"Diagnostics","title":"From a YAML file","text":"If you configure your simulation with YAML files, there are two options that are important to know about. When output_default_diagnostics is set to true, the default diagnostics for the given atmospheric model will be output. Note that they might be incompatible with your simulation (e.g., you want to output hourly maxima when the timestep is 4 hours).\n\nSecond, you can specify the diagnostics you want to output directly in the diagnostics section of your YAML file. For instance:\n\ndiagnostics:\n  - short_name: rhoa\n    output_name: a_name\n    period: 3hours\n    writer: nc\n  - reduction_time: average\n    short_name: rhoa\n    period: 12hours\n    writer: h5\n\nThis adds two diagnostics (both for rhoa). The period keyword identifies the period over which to compute the reduction and how often to save to disk. output_name is optional, and if provided, it identifies the name of the output file.\n\nFor multiple diagnostics with the same specs, it is also possible to directly pass a vector of short_names, as in\n\ndiagnostics:\n  - short_name: [rhoa, ua, ta]\n    reduction_time: average\n    period: 12hours\n\nThe default writer is NetCDF. If writer is nc or netcdf, the output is remapped non-conservatively on a Cartesian grid and saved to a NetCDF file. Currently, only 3D fields on cubed spheres are supported.","category":"section"},{"location":"diagnostics/#From-a-script","page":"Diagnostics","title":"From a script","text":"The simplest way to get started with diagnostics is to use the defaults for your atmospheric model. ClimaAtmos defines a function default_diagnostic. You can execute this function on an AtmosModel or on any of its fields to obtain a list of diagnostics ready to be passed to the simulation. So, for example\n\n\nmodel = ClimaAtmos.AtmosModel(..., moisture_model = ClimaAtmos.DryModel(), ...)\n\ndiagnostics = ClimaAtmos.default_diagnostics(model)\n# => List of diagnostics that include the ones specified for the DryModel\n\nTechnically, the diagnostics are represented as ScheduledDiagnostic objects, which contain information about what variable has to be computed, how often, where to save it, and so on (read below for more information on this). You can construct your own lists of ScheduledDiagnostics starting from the variables defined by ClimaAtmos. The DiagnosticVariables in ClimaAtmos are identified with by the short and unique name, so that you can access them directly with the function diagnostic_variable. One way to do so is by using the provided convenience functions for common operations, e.g., continuing the previous example\n\n\npush!(diagnostics, daily_max(\"air_density\", \"air_temperature\"))\n\nNow diagnostics will also contain the instructions to compute the daily maximum of air_density and air_temperature.\n\nThe diagnostics that are built-in ClimaAtmos are collected in Available diagnostic variables.\n\nIf you are using ClimaAtmos with a script-based interface, you have access to the complete flexibility in your diagnostics. Read the section about the low-level interface to see how to implement custom diagnostics, reductions, or writers.","category":"section"},{"location":"diagnostics/#The-low-level-interface","page":"Diagnostics","title":"The low-level interface","text":"Check out the documentation for the ClimaDiagnostics to find more information about the low level interface.","category":"section"},{"location":"diagnostics/#The-NetCDF-output","page":"Diagnostics","title":"The NetCDF output","text":"The NetCDF writer in ClimaAtmos saves different diagnostics to different files in the same output folder. Files are named after a combination of the diagnostic variable short_name, and the details of the temporal reduction. Inside each NetCDF file, there is only one diagnostic variable, along with the various dimensions (e.g., lat, lon, and z/z_reference).\n\nWhen topography is present, a new 1D dimension is defined z_reference. This dimension does not have direct physical meaning but can be assumed to be the \"z\" axis. Along with dimension, a new variable z is saved to the NetCDF file. In this case, z is a multidimensional array (in general 3D). z[i, j, k] which defines the elevation on the sea level of the point of indices [i, j, k].","category":"section"},{"location":"diagnostics/#I-want-to-add-a-new-diagnostic-variable","page":"Diagnostics","title":"I want to add a new diagnostic variable","text":"Diagnostic variables are represented in ClimaAtmos with a DiagnosticVariable struct. Fundamentally, a DiagnosticVariable contains metadata about the variable, and a function that computes it from the state.","category":"section"},{"location":"diagnostics/#Metadata","page":"Diagnostics","title":"Metadata","text":"The metadata we currently support is short_name, long_name, units, comments. This metadata is relevant mainly in the context of how the variable is output. Therefore, it is responsibility of the output_writer (see ScheduledDiagnostic) to handle the metadata properly. The output_writers provided by ClimaAtmos use this metadata.\n\nIn ClimaAtmos, we follow the convention that:\n\nshort_name is the name used to identify the variable in the output files and               in the file names. It is short, but descriptive. We identify               diagnostics by their short name, so the diagnostics defined by               ClimaAtmos have to have unique short_names.\nlong_name: Name used to describe the variable in the output file as attribute.\nstandard_name: Standard name, as in CF conventions\nunits: Physical units of the variable.\ncomments: More verbose explanation of what the variable is, or comments related to how             it is defined or computed.\n\nIn ClimaAtmos, we follow the CMIP6 MIP table for short names and long names where available. Standard names in the table are not used.","category":"section"},{"location":"diagnostics/#Compute-function","page":"Diagnostics","title":"Compute function","text":"The other piece of information needed to specify a DiagnosticVariable is a function compute. Schematically, a compute has to look like\n\nfunction compute(state, cache, time)\n    return ... # Calculations with the state and the cache\nend\n\nThe function takes the state, cache, and time from the integrator and returns the value of the diagnostic variable.","category":"section"},{"location":"diagnostics/#In-place-computation","page":"Diagnostics","title":"In-place computation","text":"You can alternatively provide a compute! function.  compute! takes a fourth argument, out, which is used to avoid extra memory allocations.\n\nfunction compute!(out, state, cache, time)\n    if isnothing(out)\n        return ... # Calculations with the state and the cache\n    else\n        out .= ... # Calculations with the state and the cache\n    end\nend\n\nThe first time compute! is called, out is nothing, and the function has to allocate memory and return its output. All the subsequent times, out will be the pre-allocated area of memory, so the function has to write the new value in place.\n\nIf your diagnostic depends on the details of the model, we recommend using additional functions so that the correct one can be found through dispatching. The following example demonstrates this using the compute interface. For instance, if you want to compute relative humidity, which does not make sense for dry simulations, you should define the functions\n\nfunction compute_relative_humidity(state, cache, time, moisture_model::T) where {T}\n    error(\"Cannot compute relative_humidity with moisture_model = $T\")\nend\n\nfunction compute_relative_humidity(\n    state, cache, time, moisture_model::Union{EquilMoistModel, NonEquilMoistModel},\n)\n    thermo_params = CAP.thermodynamics_params(cache.params)\n    return @. lazy(TD.relative_humidity(thermo_params, cache.ᶜts))\nend\n\ncompute_relative_humidity!(out, state, cache, time) =\n    compute_relative_humidity!(out, state, cache, time, cache.atmos.moisture_model)\n\nThis will return the correct relative humidity and throw informative errors when it cannot be computed. We could specialize compute_relative_humidity further if the relative humidity were computed differently for EquilMoistModel and NonEquilMoistModel.\n\nIn ClimaAtmos, we define some helper functions to produce error messages, so the above code can be written as\n\nfunction compute_relative_humidity(\n    state, cache, time, moisture_model::Union{EquilMoistModel, NonEquilMoistModel},\n)\n    thermo_params = CAP.thermodynamics_params(cache.params)\n    return @. lazy(TD.relative_humidity(thermo_params, cache.ᶜts))\nend\n\ncompute_relative_humidity!(out, state, cache, time) =\n    compute_relative_humidity!(out, state, cache, time, cache.atmos.moisture_model)\ncompute_relative_humidity!(_, _, _, _, model) =\n    error_diagnostic_variable(\"relative_humidity\", model)","category":"section"},{"location":"diagnostics/#The-ClimaAtmos-DiagnosticVariables","page":"Diagnostics","title":"The ClimaAtmos DiagnosticVariables","text":"ClimaAtmos comes with a collection of pre-defined DiagnosticVariable, index with their short_names. If you are extending ClimaAtmos and want to add a new diagnostic variable, go ahead and look at the files we include in diagnostics/Diagnostics.jl. You can add more diagnostics in those files or add a new one. We provide a convenience function, add_diagnostic_variable! to add new DiagnosticVariables. add_diagnostic_variable! take the same arguments as the constructor for DiagnosticVariable, but also performs additional checks. Similarly, if you want to retrieve a diagnostic from ALL_DIAGNOSTICS, use the get_diagnostic_variablefunction.","category":"section"},{"location":"topography/#Topography-in-ClimaAtmos","page":"Topography Representation","title":"Topography in ClimaAtmos","text":"Dataset source : https://www.ncei.noaa.gov/products/etopo-global-relief-model ClimaArtifact  : https://github.com/CliMA/ClimaArtifacts/tree/main/earth_orography \n\nWe currently use the ClimaUtilities SpaceVaryingInput tool to regrid (using linear interpolation) the ETOPO2022 ice-surface elevation dataset (see ClimaArtifacts) onto the required spectral element horizontal grid. The file examples/topography_spectra.jl provides simple tools to generate such regridded fields (and their spectra) on user-defined horizontal spaces. For existing ClimaAtmos simulation data, users may access the orog.nc dataset from the default diagnostic outputs to visualize or examine this data. As an example, we include plots of the generated topography on a cubed sphere with 16 elements and 64 elements per panel edge, and compare instances of unsmoothed and smoothed datasets to visualize the effect of our topography smoothing methods. \n\nElevation data (elems per panel = 16)\n\n(Image: )\n\nElevation data (elems per panel = 64)\n\n(Image: )","category":"section"},{"location":"grids/#Grids","page":"Grids","title":"Grids","text":"ClimaAtmos.jl provides several grid constructors to set up the domain layout for simulations. These grids handle the creation of the underlying ClimaCore meshes, topologies, and spaces, including optional topography.","category":"section"},{"location":"grids/#Available-Grids","page":"Grids","title":"Available Grids","text":"","category":"section"},{"location":"grids/#SphereGrid","page":"Grids","title":"SphereGrid","text":"The SphereGrid creates a grid on a cubed-sphere domain, suitable for global atmospheric simulations.\n\nusing ClimaAtmos\ngrid = SphereGrid(\n    Float64;\n    z_elem = 10,\n    radius = 6.371229e6,\n    h_elem = 6,\n)","category":"section"},{"location":"grids/#BoxGrid","page":"Grids","title":"BoxGrid","text":"The BoxGrid creates a 3D Cartesian box grid.\n\ngrid = BoxGrid(\n    Float64;\n    x_elem = 6,\n    x_max = 300000.0,\n    y_elem = 6,\n    y_max = 300000.0,\n    z_elem = 10,\n    z_max = 30000.0,\n)","category":"section"},{"location":"grids/#ColumnGrid","page":"Grids","title":"ColumnGrid","text":"The ColumnGrid creates a single column grid, used for Single Column Models (SCM).\n\ngrid = ColumnGrid(\n    Float64;\n    z_elem = 10,\n    z_max = 30000.0,\n)","category":"section"},{"location":"grids/#PlaneGrid","page":"Grids","title":"PlaneGrid","text":"The PlaneGrid creates a 2D (x-z) plane grid.\n\ngrid = PlaneGrid(\n    Float64;\n    x_elem = 6,\n    x_max = 300000.0,\n    z_elem = 10,\n    z_max = 30000.0,\n)","category":"section"},{"location":"grids/#Mesh-Ordering","page":"Grids","title":"Mesh Ordering","text":"When constructing grids, ClimaAtmos uses a space-filling curve to order the elements. This improves memory locality.\n\nHere is an example visualizing the space-filling curve for a small BoxGrid:\n\n(Image: Grid Order)","category":"section"},{"location":"surface_albedo/#Ocean-Surface-Albedo","page":"Ocean Surface Albedo Parameterization","title":"Ocean Surface Albedo","text":"The ocean surface albedo is the fraction of solar radiation that is reflected by the ocean surface. It is a key parameter in the Earth's energy balance and is important for understanding the ocean's role in the climate system. The surface ocean albedo is a function of the solar zenith angle, the sea surface roughness (which depends on wind speed) and wavelength of the incoming radiation.\n\nCurrently, there are two methods available to specify ocean albedo:","category":"section"},{"location":"surface_albedo/#1)-ConstantAlbedo","page":"Ocean Surface Albedo Parameterization","title":"1) ConstantAlbedo","text":"The default value is 0.38 (following [6]) and is used purely for idealized experiments.","category":"section"},{"location":"surface_albedo/#2)-RegressionFunctionAlbedo","page":"Ocean Surface Albedo Parameterization","title":"2) RegressionFunctionAlbedo","text":"This is an empirically-derived parameterization of the direct and diffuse surface albedo of Jin et al. (2011) [7] (note, reflectivity of the inner ocean is ignored). The direct reflection is calculated using the Fresnel reflection at the air-sea interface due to the difference in refractive index between air and water. Note that the current implementation is using the broadband representation (relative refractive index, n, is independent of wavelength). Its formulation is:\n\nα_dir(λ μ u) = r_f(n μ) - fracr_f(n μ)r_f(n_0 μ) f(μ σ(u))\n\n\nwhere:\n\nλ\nis the wavelength (currently unused)\nμ\nis the cosine of the solar zenith angle\nu\nis the wind speed\nσ(u)\nis the mean wave slope distribution width following Cox and Munk (1954), with sigma^2 = 0003 + 000512u, with u being the surface wind speed\nr_f(n μ)\nis the Fresnel reflectance (e.g., see [8]):\n\n    r_f_p(n θ) = left(fracn^2 cos(θ) - sqrtn^2 - sin^2(θ)n^2 cos(θ) + sqrtn^2 - sin^2(θ)right)^2\n\n\n    r_f_s(n θ) = left(fraccos(θ) - sqrtn^2 - sin^2(θ)cos(θ) + sqrtn^2 - sin^2(θ)right)^2\n\nwhere we assume an equal contribution from the p and s polarizations, so that r_f(n θ) = 05(r_f_p(n θ) + r_f_s(n θ)), and the perfect dielectric medium approximation.\n\nn_0=134\nis the refractive index of water for visible light\nn\nis the relative refractive index of water and air (n = n_wn_a), and is assumed to be equal to n_0 for the broadband representation\nf(μ σ)\nis the regression function, defined as:\n\nf(μ σ) = (p_1 + p_2μ + p_3μ^2 + p_4μ^3 + p_5σ + p_6σμ)  exp(p_7 + p_8μ + p_9μ^2 + p_10σ + p_11σμ)\n\nwhere the coefficients are given in the table below:\n\nCoefficient Value\np_1 0.0152\np_2 -1.7873\np_3 6.8972\np_4 -8.5778\np_5 4.071\np_6 -7.6446\np_7 0.1643\np_8 -7.8409\np_9 -3.5639\np_10 -2.3588\np_11 10.0538\n\nDiffuse reflection is calculated depending on atmospheric conditions. For clear sky, it is calculated using nearly isotropic Rayleigh scattering, and for cloudy sky, the albedo is adjusted for the presence of clouds. The formulations are:\n\nα_diff(λ μ u) = -01482 - 0012σ(u) + 01608n - 00244nσ(u)\n\nfor clear sky, and\n\nα_diff(λ μ u) = -01479 + 01502n - 0016nσ(u)\n\nfor cloudy sky. In the current implementation we assume clear skies everywhere.","category":"section"},{"location":"surface_albedo/#3)-CouplerAlbedo","page":"Ocean Surface Albedo Parameterization","title":"3) CouplerAlbedo","text":"This informs ClimaAtmos that albedo will be set by the coupler.","category":"section"},{"location":"surface_albedo/#Comparison-of-RegressionFunctionAlbedo-with-Jin-et-al.-(2011)","page":"Ocean Surface Albedo Parameterization","title":"Comparison of RegressionFunctionAlbedo with Jin et al. (2011)","text":"\n\ninclude(\"surface_albedo_jin11_plots.jl\")\n\ndirect albedo (compare with Fig. 2)\n\n(Image: )\n\ndiffuse albedo (compare with Fig. 4)\n\n(Image: )","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Initial-conditions","page":"API","title":"Initial conditions","text":"","category":"section"},{"location":"api/#General","page":"API","title":"General","text":"","category":"section"},{"location":"api/#Plane-/-Box","page":"API","title":"Plane / Box","text":"","category":"section"},{"location":"api/#Sphere","page":"API","title":"Sphere","text":"","category":"section"},{"location":"api/#Cases-from-literature","page":"API","title":"Cases from literature","text":"","category":"section"},{"location":"api/#Helper","page":"API","title":"Helper","text":"","category":"section"},{"location":"api/#Grids","page":"API","title":"Grids","text":"","category":"section"},{"location":"api/#Jacobian","page":"API","title":"Jacobian","text":"","category":"section"},{"location":"api/#Topography","page":"API","title":"Topography","text":"","category":"section"},{"location":"api/#Internals","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/#ClimaAtmos.InitialConditions.InitialCondition","page":"API","title":"ClimaAtmos.InitialConditions.InitialCondition","text":"InitialCondition\n\nA mechanism for specifying the LocalState of an AtmosModel at every point in the domain. Given some initial_condition, calling initial_condition(params) returns a function of the form local_state(local_geometry)::LocalState.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.IsothermalProfile","page":"API","title":"ClimaAtmos.InitialConditions.IsothermalProfile","text":"IsothermalProfile(; temperature = 300)\n\nAn InitialCondition with a uniform temperature profile.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.DecayingProfile","page":"API","title":"ClimaAtmos.InitialConditions.DecayingProfile","text":"DecayingProfile(; perturb = true)\n\nAn InitialCondition with a decaying temperature profile, and with an optional perturbation to the temperature.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.hydrostatic_pressure_profile","page":"API","title":"ClimaAtmos.InitialConditions.hydrostatic_pressure_profile","text":"hydrostatic_pressure_profile(; thermo_params, p_0, [T, θ, q_tot, z_max])\n\nSolves the initial value problem p'(z) = -g * ρ(z) for all z ∈ [0, z_max], given p(0), either T(z) or θ(z), and optionally also q_tot(z). If q_tot(z) is not given, it is assumed to be 0. If z_max is not given, it is assumed to be 30 km. Note that z_max should be the maximum elevation to which the specified profiles T(z), θ(z), and/or q_tot(z) are valid.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAtmos.InitialConditions.ConstantBuoyancyFrequencyProfile","page":"API","title":"ClimaAtmos.InitialConditions.ConstantBuoyancyFrequencyProfile","text":"ConstantBuoyancyFrequencyProfile()\n\nAn InitialCondition with a constant Brunt-Vaisala frequency and constant wind velocity, where the pressure profile is hydrostatically balanced. This is currently the only InitialCondition that supports the approximation of a steady-state solution.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.DryDensityCurrentProfile","page":"API","title":"ClimaAtmos.InitialConditions.DryDensityCurrentProfile","text":"DryDensityCurrentProfile(; perturb = false)\n\nAn InitialCondition with an isothermal background profile, with a negatively buoyant bubble, and with an optional perturbation to the temperature.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.RisingThermalBubbleProfile","page":"API","title":"ClimaAtmos.InitialConditions.RisingThermalBubbleProfile","text":"RisingThermalBubbleProfile(; perturb = false)\n\nAn InitialCondition with an isothermal background profile, with a positively buoyant bubble, and with an optional perturbation to the temperature.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.DryBaroclinicWave","page":"API","title":"ClimaAtmos.InitialConditions.DryBaroclinicWave","text":"DryBaroclinicWave(; perturb = true, deep_atmosphere = false)\n\nAn InitialCondition with a dry baroclinic wave, and with an optional perturbation to the horizontal velocity.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.MoistBaroclinicWaveWithEDMF","page":"API","title":"ClimaAtmos.InitialConditions.MoistBaroclinicWaveWithEDMF","text":"MoistBaroclinicWaveWithEDMF(; perturb = true, deep_atmosphere = false)\n\nThe same InitialCondition as MoistBaroclinicWave, except with an initial TKE of 0 and an initial draft area fraction of 0.2.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.MoistAdiabaticProfileEDMFX","page":"API","title":"ClimaAtmos.InitialConditions.MoistAdiabaticProfileEDMFX","text":"MoistAdiabaticProfileEDMFX(; perturb = true)\n\nAn InitialCondition with a moist adiabatic temperature profile, and with an optional perturbation to the temperature.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.GABLS","page":"API","title":"ClimaAtmos.InitialConditions.GABLS","text":"GABLS\n\nThe InitialCondition described in [9], but with a hydrostatically balanced pressure profile.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.DYCOMS_RF01","page":"API","title":"ClimaAtmos.InitialConditions.DYCOMS_RF01","text":"DYCOMS_RF01\n\nThe InitialCondition described in [10], but with a hydrostatically balanced pressure profile.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.DYCOMS_RF02","page":"API","title":"ClimaAtmos.InitialConditions.DYCOMS_RF02","text":"DYCOMS_RF02\n\nThe InitialCondition described in [11], but with a hydrostatically balanced pressure profile.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.Rico","page":"API","title":"ClimaAtmos.InitialConditions.Rico","text":"Rico\n\nThe InitialCondition described in [12], but with a hydrostatically balanced pressure profile.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.TRMM_LBA","page":"API","title":"ClimaAtmos.InitialConditions.TRMM_LBA","text":"TRMM_LBA\n\nThe InitialCondition described in [13], but with a hydrostatically balanced pressure profile.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.Bomex","page":"API","title":"ClimaAtmos.InitialConditions.Bomex","text":"Bomex\n\nThe InitialCondition described in [14], but with a hydrostatically balanced pressure profile.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.Soares","page":"API","title":"ClimaAtmos.InitialConditions.Soares","text":"Soares\n\nThe InitialCondition described in [15], but with a hydrostatically balanced pressure profile.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.RCEMIPIIProfile","page":"API","title":"ClimaAtmos.InitialConditions.RCEMIPIIProfile","text":"RCEMIPIIProfile(temperature, humidity)\n\nAn InitialCondition following the sounding to initialize simulations for RCEMIPII as described by Wing et. al. (2018) (https://doi.org/10.5194/gmd-11-793-2018). There are three input profiles: RCEMIPIIProfile295, RCEMIPIIProfile300, and RCEMIPIIProfile305, that specify three different SST temperatures and different initial specific humidity profiles. Note: this should be used for RCEsmall and NOT RCElarge - RCElarge must be initialized with the final state of RCE_small.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.InitialConditions.ColumnInterpolatableField","page":"API","title":"ClimaAtmos.InitialConditions.ColumnInterpolatableField","text":"ColumnInterpolatableField(::Fields.ColumnField)\n\nA column field object that can be interpolated in the z-coordinate. For example:\n\ncif = ColumnInterpolatableField(column_field)\nz = 1.0\ncolumn_field_at_z = cif(z)\n\nwarn: Warn\nThis function allocates and is not GPU-compatible so please avoid using this inside step! only use this for initialization.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.ColumnGrid","page":"API","title":"ClimaAtmos.ColumnGrid","text":"ColumnGrid(::Type{FT}; kwargs...)\n\nCreate a ColumnGrid.\n\nArguments\n\nFT: the floating-point type [Float32, Float64]\n\nKeyword Arguments\n\ncontext = ClimaComms.context(): the ClimaComms communications context\nz_elem = 10: the number of z-points\nz_max = 30000.0: the domain maximum along the z-direction\nz_stretch = true: whether to use vertical stretching\ndz_bottom = 500.0: bottom layer thickness for stretching\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAtmos.SphereGrid","page":"API","title":"ClimaAtmos.SphereGrid","text":"SphereGrid(::Type{FT}; kwargs...)\n\nCreate an ExtrudedCubedSphereGrid with topography support.\n\nArguments\n\nFT: the floating-point type [Float32, Float64]\n\nKeyword Arguments\n\ncontext = ClimaComms.context(): the ClimaComms communications context\nz_elem = 10: the number of z-points\nz_max = 30000.0: the domain maximum along the z-direction\nz_stretch = true: whether to use vertical stretching\ndz_bottom = 500.0: bottom layer thickness for stretching\nradius = 6.371229e6: the radius of the cubed sphere\nh_elem = 6: the number of horizontal elements per side of every panel (6 panels in total)\nnh_poly = 3: the polynomial order. Note: The number of quadrature points in 1D within each horizontal element is then n_quad_points = nh_poly + 1\nbubble = false: enables the \"bubble correction\" for more accurate element areas when computing the spectral element space\ndeep_atmosphere = true: use deep atmosphere equations and metric terms, otherwise assume columns are cylindrical (shallow atmosphere)\ntopography = NoTopography(): topography type\ntopography_damping_factor = 5.0: factor by which smallest resolved length-scale is to be damped\nmesh_warp_type = SLEVEWarp{FT}(): mesh warping type (SLEVEWarp or LinearWarp)\ntopo_smoothing = false: apply topography smoothing\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAtmos.PlaneGrid","page":"API","title":"ClimaAtmos.PlaneGrid","text":"PlaneGrid(::Type{FT}; kwargs...)\n\nCreate a SliceXZGrid with topography support.\n\nArguments\n\nFT: the floating-point type [Float32, Float64]\n\nKeyword Arguments\n\ncontext = ClimaComms.context(): the ClimaComms communications context\nx_elem = 6: the number of x-points\nx_max = 300000.0: the domain maximum along the x-direction\nz_elem = 10: the number of z-points\nz_max = 30000.0: the domain maximum along the z-direction\nnh_poly = 3: the polynomial order. Note: The number of quadrature points in 1D within each horizontal element is then n_quad_points = nh_poly + 1\nz_stretch = true: whether to use vertical stretching\ndz_bottom = 500.0: bottom layer thickness for stretching\nbubble = false: enables the \"bubble correction\" for more accurate element areas when computing the spectral element space. Note: Currently not supported by SliceXZGrid in ClimaCore.\nperiodic_x = true: use periodic domain along x-direction\ntopography = NoTopography(): topography type\ntopography_damping_factor = 5.0: factor by which smallest resolved length-scale is to be damped\nmesh_warp_type = LinearWarp(): mesh warping type (SLEVEWarp or LinearWarp)\ntopo_smoothing = false: apply topography smoothing\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAtmos.BoxGrid","page":"API","title":"ClimaAtmos.BoxGrid","text":"BoxGrid(::Type{FT}; kwargs...)\n\nCreate a Box3DGrid with topography support.\n\nArguments\n\nFT: the floating-point type [Float32, Float64]\n\nKeyword Arguments\n\ncontext = ClimaComms.context(): the ClimaComms communications context\nx_elem = 6: the number of x-points\nx_max = 300000.0: the domain maximum along the x-direction\ny_elem = 6: the number of y-points\ny_max = 300000.0: the domain maximum along the y-direction\nz_elem = 10: the number of z-points\nz_max = 30000.0: the domain maximum along the z-direction\nnh_poly = 3: the polynomial order. Note: The number of quadrature points in 1D within each horizontal element is then n_quad_points = nh_poly + 1\nz_stretch = true: whether to use vertical stretching\ndz_bottom = 500.0: bottom layer thickness for stretching\nbubble = false: enables the \"bubble correction\" for more accurate element areas when computing the spectral element space.\nperiodic_x = true: use periodic domain along x-direction\nperiodic_y = true: use periodic domain along y-direction\ntopography = NoTopography(): topography type\ntopography_damping_factor = 5.0: factor by which smallest resolved length-scale is to be damped\nmesh_warp_type = LinearWarp(): mesh warping type (SLEVEWarp or LinearWarp)\ntopo_smoothing = false: apply topography smoothing\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAtmos.Jacobian","page":"API","title":"ClimaAtmos.Jacobian","text":"Jacobian(alg, Y, atmos; [verbose])\n\nWrapper for a JacobianAlgorithm and its cache, which it uses to update and invert the Jacobian. The optional verbose flag specifies whether debugging information should be printed during initialization.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.JacobianAlgorithm","page":"API","title":"ClimaAtmos.JacobianAlgorithm","text":"JacobianAlgorithm\n\nA description of how to compute the matrix RY, where R(Y) denotes the residual of an implicit step with the state Y. Concrete implementations of this abstract type should define 3 methods:\n\njacobian_cache(alg::JacobianAlgorithm, Y, atmos; [verbose])\nupdate_jacobian!(alg::JacobianAlgorithm, cache, Y, p, dtγ, t)\ninvert_jacobian!(alg::JacobianAlgorithm, cache, ΔY, R)\n\nTo facilitate debugging, concrete implementations should also define\n\nfirst_column_block_arrays(alg::JacobianAlgorithm, Y, p, dtγ, t)\n\nSee Implicit Solver for additional background information.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.ManualSparseJacobian","page":"API","title":"ClimaAtmos.ManualSparseJacobian","text":"ManualSparseJacobian(\n    topography_flag,\n    diffusion_flag,\n    sgs_advection_flag,\n    sgs_entr_detr_flag,\n    sgs_mass_flux_flag,\n    sgs_nh_pressure_flag,\n    sgs_vertdiff_flag,\n    approximate_solve_iters,\n)\n\nA JacobianAlgorithm that approximates the Jacobian using analytically derived tendency derivatives and inverts it using a specialized nested linear solver. Certain groups of derivatives can be toggled on or off by setting their DerivativeFlags to either UseDerivative or IgnoreDerivative.\n\nArguments\n\ntopography_flag::DerivativeFlag: whether the derivative of vertical contravariant velocity with respect to horizontal covariant velocity should be computed\ndiffusion_flag::DerivativeFlag: whether the derivatives of the grid-scale diffusion tendency should be computed\nsgs_advection_flag::DerivativeFlag: whether the derivatives of the subgrid-scale advection tendency should be computed\nsgs_entr_detr_flag::DerivativeFlag: whether the derivatives of the subgrid-scale entrainment and detrainment tendencies should be computed\nsgs_mass_flux_flag::DerivativeFlag: whether the derivatives of the subgrid-scale mass flux tendency should be computed\nsgs_nh_pressure_flag::DerivativeFlag: whether the derivatives of the subgrid-scale non-hydrostatic pressure drag tendency should be computed\nsgs_vertdiff_flag::DerivativeFlag: whether the derivatives of the subgrid-scale vertical diffusion tendency should be computed\napproximate_solve_iters::Int: number of iterations to take for the approximate linear solve required when the diffusion_flag is UseDerivative\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.AutoDenseJacobian","page":"API","title":"ClimaAtmos.AutoDenseJacobian","text":"AutoDenseJacobian([max_simultaneous_derivatives])\n\nA JacobianAlgorithm that computes the Jacobian using forward-mode automatic differentiation, without making any assumptions about sparsity structure. After the dense matrix for each spatial column is updated, parallel_lu_factorize! computes its LU factorization in parallel across all columns. The linear solver is also run in parallel with parallel_lu_solve!.\n\nTo automatically compute the derivative of implicit_tendency! with respect to Y, we first create copies of Y, p.precomputed, and p.scratch in which every floating-point number is replaced by a dual number from ForwardDiff.jl. A dual number can be expressed as Xᴰ = X + ε₁x₁ + ε₂x₂ +  + εₙxₙ, where X and xᵢ are floating-point numbers, and where εᵢ is a hyperreal number that satisfies εᵢεⱼ = 0. If the i-th value in dual column state Yᴰ is set to Yᴰᵢ = Yᵢ + 1εᵢ, where Yᵢ is the i-th value in the column state Y, then evaluating the implicit tendency of the dual column state generates a dense representation of the Jacobian matrix TY. Specifically, the i-th value in the dual column tendency Tᴰ = T(Yᴰ) is Tᴰᵢ = Tᵢ + (TᵢY₁)ε₁ +  + (TᵢYₙ)εₙ, where Tᵢ is the i-th value in the column tendency T(Y), and where n is the number of values in Y. In other words, the entry in the i-th row and j-th column of the matrix TY is the coefficient of εⱼ in Tᴰᵢ. The size of the dense matrix scales as O(n^2), leading to very large memory requirements at higher vertical resolutions.\n\nWhen the number of values in each column is very large, computing the entire dense matrix in a single evaluation of implicit_tendency! can be too expensive to compile and run. So, the dual number components are split into partitions with a maximum size of max_simultaneous_derivatives, and we call implicit_tendency! once for each partition. That is, if the partition size is s, then the first partition evaluates the coefficients of ε₁ through εₛ, the second evaluates the coefficients of εₛ₁ through ε₂ₛ, and so on until εₙ. The default partition size is 32.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.AutoSparseJacobian","page":"API","title":"ClimaAtmos.AutoSparseJacobian","text":"AutoSparseJacobian(sparse_jacobian_alg, [padding_bands_per_block])\n\nA JacobianAlgorithm that computes the Jacobian using forward-mode automatic differentiation, assuming that the Jacobian's sparsity structure is given by sparse_jacobian_alg.\n\nOnly entries that are exptected to be nonzero according to the sparsity structure are updated, but any other entries that are nonzero can introduce errors to the updated entries. This issue can be avoided by adding padding bands to blocks that are likely to introduce errors. In cases where the default padding bands are insufficient, padding_bands_per_block can be specified to add a fixed number of padding bands to every block.\n\nFor more information about this algorithm, see Implicit Solver.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.CosineTopography","page":"API","title":"ClimaAtmos.CosineTopography","text":"CosineTopography{D, FT}(; h_max = 25, λ = 25e3)\n\nCosine hill topography in 2D or 3D.\n\nArguments\n\nh_max::FT: Maximum elevation (m)\nλ::FT: Wavelength of the cosine hills (m)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.AgnesiTopography","page":"API","title":"ClimaAtmos.AgnesiTopography","text":"AgnesiTopography{FT}(; h_max = 25, x_center = 50e3, a = 5e3)\n\nWitch of Agnesi mountain topography for 2D simulations.\n\nArguments\n\nh_max: Maximum elevation (m)\nx_center: Center position (m)\na: Mountain width parameter (m)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.ScharTopography","page":"API","title":"ClimaAtmos.ScharTopography","text":"ScharTopography{FT}(; h_max = 25, x_center = 50e3, λ = 4e3, a = 5e3)\n\nSchar mountain topography for 2D simulations.\n\nArguments\n\nh_max: Maximum elevation (m)\nx_center: Center position (m)\nλ: Wavelength parameter (m)\na: Mountain width parameter (m)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.EarthTopography","page":"API","title":"ClimaAtmos.EarthTopography","text":"EarthTopography()\n\nEarth topography from ETOPO2022 data files.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.DCMIP200Topography","page":"API","title":"ClimaAtmos.DCMIP200Topography","text":"DCMIP200Topography()\n\nSurface elevation for the DCMIP-2-0-0 test problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.Hughes2023Topography","page":"API","title":"ClimaAtmos.Hughes2023Topography","text":"Hughes2023Topography()\n\nSurface elevation for baroclinic wave test from Hughes and Jablonowski (2023).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.SLEVEWarp","page":"API","title":"ClimaAtmos.SLEVEWarp","text":"SLEVEWarp(; eta = 0.7, s = 10.0)\n\nSmooth Level Vertical (SLEVE) coordinate warping for terrain-following meshes.\n\nArguments\n\neta: Threshold parameter (if z/z_top > eta, no warping is applied). Default: 0.7\ns: Decay scale parameter controlling how quickly the warping decays with height. Default: 10.0\n\nReferences\n\nSchär et al. (2002), \"A new terrain-following vertical coordinate formulation  for atmospheric prediction models\", Mon. Wea. Rev.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.LinearWarp","page":"API","title":"ClimaAtmos.LinearWarp","text":"LinearWarp()\n\nLinear mesh warping that uniformly distributes vertical levels between the surface and top of the domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaAtmos.parallel_lu_factorize!","page":"API","title":"ClimaAtmos.parallel_lu_factorize!","text":"parallel_lu_factorize!(device, matrices, ::Val{N})\n\nRuns a parallel LU factorization algorithm on the specified device. If each slice matrices[1:N, 1:N, i] represents a matrix Mᵢ, this function overwrites it with the lower triangular matrix Lᵢ and the upper triangular matrix Uᵢ, where Mᵢ = Lᵢ * Uᵢ. The value of N must be wrapped in a Val to ensure that it is statically inferrable, which allows the LU factorization to avoid dynamic local memory allocations.\n\nThe runtime of this algorithm scales as O(N^3).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaAtmos.parallel_lu_solve!","page":"API","title":"ClimaAtmos.parallel_lu_solve!","text":"parallel_lu_solve!(device, vectors, matrices, ::Val{N})\n\nRuns a parallel LU solver algorithm on the specified device. If each slice vectors[1:N, i] represents a vector vᵢ, and if each slice matrices[1:N, 1:N, i] represents a matrix Lᵢ * Uᵢ that was factorized by parallel_lu_factorize!, this function overwrites the slice vectors[1:N, i] with (Lᵢ * Uᵢ)¹ * vᵢ. The value of N must be wrapped in a Val to ensure that it is statically inferrable, which allows the LU solver to avoid dynamic local memory allocations.\n\nThe runtime of this algorithm scales as O(N^2).\n\n\n\n\n\n","category":"function"},{"location":"equations/#Equations","page":"Equations","title":"Equations","text":"note: Note\nThis follows what is currently implemented in examples: it should be kept up-to-date as code is modified. If you think something should be changed (but hasn't been), please add a note.\n\nThis describes the ClimaAtmos model equations and its discretizations. Where possible, we use a coordinate invariant form: the ClimaCore operators generally handle the conversions between bases internally.","category":"section"},{"location":"equations/#Prognostic-variables","page":"Equations","title":"Prognostic variables","text":"rho: density in kg/m³. This is discretized at cell centers.\nboldsymbolu velocity, a vector in m/s. This is discretized via boldsymbolu = boldsymbolu_h + boldsymbolu_v where\nboldsymbolu_h = u_1 boldsymbole^1 + u_2 boldsymbole^2 is the projection onto horizontal covariant components (covariance here means with respect to the reference element), stored at cell centers.\nboldsymbolu_v = u_3 boldsymbole^3 is the projection onto the vertical covariant components, stored at cell faces.\nenergy, stored at cell centers; can be either:\nrho e: total energy in J/m³\nrho e_textint: internal energy in J/m³\nrho chi: other conserved scalars (moisture, tracers, etc), again stored at cell centers.","category":"section"},{"location":"equations/#Operators","page":"Equations","title":"Operators","text":"We make use of the following operators","category":"section"},{"location":"equations/#Reconstruction","page":"Equations","title":"Reconstruction","text":"I^c is the face-to-center reconstruction operator (arithmetic mean)\nI^f is the center-to-face reconstruction operator (arithmetic mean)\nWI^f is the center-to-face weighted reconstruction operator\nWI^f(J x) = I^f(J*x)  I^f(J), where J is the value of the Jacobian for use in the weighted interpolation operator\nU^f is the 1st or 3rd-order center-to-face upwind product operator # fix link","category":"section"},{"location":"equations/#Differential-operators","page":"Equations","title":"Differential operators","text":"hatmathcalD_h is the discrete horizontal spectral weak divergence.\nmathcalD^c_v is the face-to-center vertical divergence.\n\ntodo: Todo\nAdd vertical diffusive tendencies (including surface fluxes)\n\nmathcalG_h is the discrete horizontal spectral gradient.\nmathcalG^f_v is the center-to-face vertical gradient.\nthe gradient is set to 0 at the top and bottom boundaries.\nmathcalC_h is the curl components involving horizontal derivatives\nmathcalC_hboldsymbolu_h returns a vector with only vertical contravariant components.\nmathcalC_hboldsymbolu_v returns a vector with only horizontal contravariant components.\nhatmathcalC_h is the weak curl components involving horizontal derivatives\nmathcalC^f_v is the center-to-face curl involving vertical derivatives.\nmathcalC^f_vboldsymbolu_h returns a vector with only a horizontal contravariant component.\nthe curl is set to 0 at the top and bottom boundaries.\nWe need to clarify how best to handle this.","category":"section"},{"location":"equations/#Projection","page":"Equations","title":"Projection","text":"mathcalP is the direct stiffness summation (DSS) operation, which computes the projection onto the continuous spectral element basis.","category":"section"},{"location":"equations/#Auxiliary-and-derived-quantities","page":"Equations","title":"Auxiliary and derived quantities","text":"boldsymbolOmega is the planetary angular velocity. We use either:\na shallow atmosphere approximation, with  math  \\boldsymbol{\\Omega} = \\Omega \\sin(\\phi) \\boldsymbol{e}^v   where phi is latitude, and Omega is the planetary rotation rate in rads/sec (for Earth, 729212 times 10^-5 s^-1) and boldsymbole^v is the unit radial basis vector. This implies that the horizontal contravariant component boldsymbolOmega^h is zero.\na deep atmosphere, with  math  \\boldsymbol{\\Omega} = (0, 0, \\Omega)  i.e. aligned with Earth's rotational axis.\ntildeboldsymbolu is the mass-weighted reconstruction of velocity at the interfaces: by interpolation of contravariant components\n\nbarboldsymbolu is the reconstruction of velocity at cell-centers, carried out by linear interpolation of the covariant vertical component:\nbarboldsymbolu = boldsymbolu_h + I_c(boldsymbolu_v)\nPhi = g z is the geopotential, where g is the gravitational acceleration rate and z is altitude above the mean sea level.\nK = tfrac12 boldsymbolu^2 is the specific kinetic energy (J/kg), reconstructed at cell centers by\nK = tfrac12 (boldsymbolu_h cdot boldsymbolu_h + 2 boldsymbolu_h cdot I_c (boldsymbolu_v) + I_c(boldsymbolu_v cdot boldsymbolu_v))\nwhere boldsymbolu_h is defined on cell-centers, boldsymbolu_v is defined on cell-faces, and I_c (boldsymbolu_v) is interpolated using covariant components.\np is air pressure, derived from the thermodynamic state, reconstructed at cell centers.\nPi = (fracpp_0)^fracR_dc_pd is the Exner function evaluated with dry-air constants.\nboldsymbolF_R are the radiative fluxes: these are assumed to align vertically (i.e. the horizontal contravariant components are zero), and are constructed at cell faces from RRTMGP.jl.\nnu_u, nu_h, and nu_chi are hyperdiffusion coefficients, and c is the divergence damping factor.\nNo-flux boundary conditions are enforced by requiring the third contravariant component of the face-valued velocity at the boundary, boldsymboltildeu^v, to be zero. The vertical covariant velocity component is computed as\ntildeu_v = tfrac-(u_1g^31 + u_2g^32)g^33","category":"section"},{"location":"equations/#Equations-and-discretizations","page":"Equations","title":"Equations and discretizations","text":"","category":"section"},{"location":"equations/#Mass","page":"Equations","title":"Mass","text":"Follows the continuity equation\n\nfracpartialpartial t rho = - nabla cdot(rho boldsymbolu) + rho mathcalS_qt\n\nThis is discretized using the following\n\nfracpartialpartial t rho\n= - hatmathcalD_h rho barboldsymbolu - mathcalD^c_v leftWI^f( J rho) tildeboldsymbolu right + rho mathcalS_qt\n\nwith the\n\n-mathcalD^c_vWI^f(J rho) boldsymbolu_v\n\nterm treated implicitly (check this)","category":"section"},{"location":"equations/#Momentum","page":"Equations","title":"Momentum","text":"Uses the advective form equation\n\nfracpartialpartial t boldsymbolu  = - (2 boldsymbolOmega + nabla times boldsymbolu) times boldsymbolu - c_pd (theta_v - theta_v r) nabla_h Pi  - nabla_h (Phi - Phi_r) + K\n\nHere, we use the Exner function to compute pressure gradients and are subtracting a hydrostatic reference state\n\n- frac1rho nabla p = - c_pd theta_v Pi\n\nwhere theta_v is the virtual potential temperature. theta_vr = T_r  Pi is a reference virtual potential temperature (with reference temperature T_r), and\n\nPhi_r = -c_pd left T_textmin log(Pi) + frac(T_textsfc - T_textmin)n_s (Pi^n_s - 1) right\n\nis a reference geopotential, which satisfies the hydrostatic balance equation c_pd theta_vr nabla Pi + nabla Phi_r = 0 for any Pi. We use the reference temperature profile T_r = T_textmin + (T_textsfc - T_textmin) Pi^n_s, with constants T_textmin = 215K, T_textsfc= 288K, and n_s = 7.","category":"section"},{"location":"equations/#Horizontal-momentum","page":"Equations","title":"Horizontal momentum","text":"By breaking the curl and cross product terms into horizontal and vertical contributions, and removing zero terms (e.g. nabla_v  times boldsymbolu_v = 0), we obtain\n\nfracpartialpartial t boldsymbolu_h  =\n  - (2 boldsymbolOmega^h + nabla_v times boldsymbolu_h +  nabla_h times boldsymbolu_v) times boldsymbolu^v\n  - (2 boldsymbolOmega^v + nabla_h times boldsymbolu_h) times boldsymbolu^h\n  - c_pd (theta_v - theta_v r) nabla_h Pi  - nabla_h (Phi - Phi_r) + K\n\nwhere boldsymbolu^h and boldsymbolu^v are the horizontal and vertical contravariant vectors.\n\nThe effect of topography is accounted for through the computation of the contravariant velocity components (projections from the covariant velocity representation) prior to computing the cross-product contributions.\n\nThis is stabilized with the addition of 4th-order vector hyperviscosity\n\n-nu_u  nabla_h^2 (nabla_h^2(boldsymboloverlineu))\n\nprojected onto the first two contravariant directions, where nabla_h^2(boldsymbolv) is the horizontal vector Laplacian. For grid scale hyperdiffusion, boldsymbolv is identical to boldsymboloverlineu, the cell-center valued velocity vector.\n\nnabla_h^2(boldsymbolv) = nabla_h(nabla_h cdot boldsymbolv) - nabla_h times (nabla_h times boldsymbolv)\n\nThe (2 boldsymbolOmega^h + nabla_v times boldsymbolu_h + nabla_h times boldsymbolu_v) times boldsymbolu^v term is discretized as:\n\nfracI^c(2 boldsymbolOmega^h + mathcalC^f_vboldsymbolu_h + mathcalC_hboldsymbolu_v) times (I^f(rho J)tildeboldsymbolu^v)rho J\n\nwhere\n\nomega^h = (nabla_v times boldsymbolu_h + nabla_h times boldsymbolu_v)\n\nThe (2 boldsymbolOmega^v + nabla_h times boldsymbolu_h) times boldsymbolu^h term is discretized as\n\n(2 boldsymbolOmega^v + mathcalC_hboldsymbolu_h) times boldsymbolu^h\n\nand the c_pd (theta_v - theta_vr) nabla_h Pi + nabla_h (Phi - Phi_r + K) term is discretized as\n\nc_pd (theta_v - theta_vr) mathcalG_hPi + mathcalG_hPhi - Phi_r + K \n\nwhere all these terms are treated explicitly.\n\nThe hyperviscosity term is\n\n- nu_u left c  hatmathcalG_h ( mathcalD(boldsymbolpsi_h) ) - hatmathcalC_h( mathcalC_h( boldsymbolpsi_h )) right\n\nwhere\n\nboldsymbolpsi_h = mathcalP left hatmathcalG_h ( mathcalD(boldsymbolu_h) ) - hatmathcalC_h( mathcalC_h( boldsymbolu_h )) right","category":"section"},{"location":"equations/#Vertical-momentum","page":"Equations","title":"Vertical momentum","text":"Similarly for vertical velocity\n\nfracpartialpartial t boldsymbolu_v  =\n  - (2 boldsymbolOmega^h + nabla_v times boldsymbolu_h + nabla_h times boldsymbolu_v) times boldsymbolu^h\n  -c_pd (theta_v - theta_v r) nabla_v Pi  - nabla_v (Phi - Phi_r)\n\nThe (2 boldsymbolOmega^h + nabla_v times boldsymbolu_h + nabla_h times boldsymbolu_v) times boldsymbolu^h term is discretized as\n\n(2 boldsymbolOmega^h + mathcalC^f_vboldsymbolu_h + mathcalC_hboldsymbolu_v) times I^f(boldsymbolu^h) \n\nThe nabla_v K term is discretized as\n\nmathcalG^f_vK\n\nThe c_pd (theta_v - theta_vr) nabla_v Pi + nabla_v (Phi - Phi_r) term is discretized as\n\nI^fc_pd (theta_v - theta_v r )  mathcalG^f_vPi - mathcalG^f_vPhi - Phi_r\n\nand is treated implicitly.\n\nThis is stabilized with the addition of 4th-order vector hyperviscosity\n\n-nu_u  nabla_h^2 (nabla_h^2(boldsymboloverlineu))\n\nprojected onto the third contravariant direction.","category":"section"},{"location":"equations/#Total-energy","page":"Equations","title":"Total energy","text":"fracpartialpartial t rho e = - nabla cdot((rho e + p) boldsymbolu + boldsymbolF_R) + rho mathcalS_e\n\nwhich is stabilized with the addition of a 4th-order hyperdiffusion term on total enthalpy:\n\n- nu_h nabla cdot left( rho nabla^3 left(fracρe + pρ right)right)\n\nThis is discretized using\n\nfracpartialpartial t rho e approx\n- hatmathcalD_h (rho e + p) barboldsymbolu \n- mathcalD^c_v left WI^f(Jrho)   tildeboldsymbolu  I^f left(fracrho e + prho right)\n  + boldsymbolF_R right - nu_h hatmathcalD_h( rho mathcalG_h(psi) )\n\nwhere\n\npsi = mathcalP left hatmathcalD_h left( mathcalG_h left(fracρe + pρ right)right) right\n\nCurrently the central reconstruction\n\n- mathcalD^c_v left WI^f(Jrho)   tildeboldsymbolu  I^f left(fracrho e + prho right) right\n\nis treated implicitly.\n\ntodo: Todo\nThe Jacobian computation should be updated so that the upwinded term- mathcalD^c_vleftWI^f(J rho) U^fleft(boldsymbolu_v fracrho e + prho right)rightis treated implicitly.","category":"section"},{"location":"equations/#Scalars","page":"Equations","title":"Scalars","text":"For an arbitrary scalar chi, the density-weighted scalar rhochi follows the continuity equation\n\nfracpartialpartial t rho chi = - nabla cdot(rho chi boldsymbolu) + rho mathcalS_chi\n\nThis is stabilized with the addition of a 4th-order hyperdiffusion term\n\n- nu_chi nabla cdot(rho nabla^3(chi))\n\nThis is discretized using\n\nfracpartialpartial t rho chi approx\n- hatmathcalD_h rho chi barboldsymbolu\n- mathcalD^c_v left WI^f(Jrho)  U^fleft( tildeboldsymbolu  fracrho chirho right) right\n- nu_chi hatmathcalD_h ( rho  mathcalG_h (psi) )\n\nwhere\n\npsi = mathcalP left hatmathcalD_h left( mathcalG_h left( fracrho chirho right)right) right\n\nCurrently the central reconstruction\n\n- mathcalD^c_v left WI^f(Jrho)  tildeboldsymbolu  I^fleft( fracrho chirho right) right\n\nis treated implicitly.\n\ntodo: Todo\nThe Jacobian computation should be updated so that the upwinded term- mathcalD^c_vleftWI^f(J rho) U^fleft(I^f(boldsymbolu_h) + boldsymbolu_v fracrho chirho right) rightis treated implicitly.","category":"section"},{"location":"radiative_equilibrium/#Radiative-Equilibrium-Example","page":"Radiative Equilibrium","title":"Radiative Equilibrium Example","text":"A suite of concrete examples are provided here as a guidance for running single column Radiative Equilibrium.  ","category":"section"},{"location":"radiative_equilibrium/#Radiative-Equilibrium","page":"Radiative Equilibrium","title":"Radiative Equilibrium","text":"Radiative equilibrium is a useful framework for analyzing atmospheric temperature profiles with different atmosphere conditions. In radiative equilibrium, we only consider heat exchange from radiation. In this example, we only match the total energy, and assume a fixed relative humidity to get specific humidity.\n\nTo run a radiative equilibrium simulation, create a yaml file (or use a default one) and run the following commands in your terminal (after instantiating the necessary packages):\n\nThe yaml file should look something like this: mysim.yml\n\nrad: \"clearsky\" \nidealized_h2o: true \nhyperdiff: false \nconfig: \"column\" \ninitial_condition: \"IsothermalProfile\" \nz_max: 70000\nz_elem: 70 \ndz_bottom: 100 \nt_end: \"654days\" \ndt: \"3hours\" \ndt_save_state_to_disk: \"100days\" \nprognostic_surface: true\njob_id: \"single_column_radiative_equilibrium_clearsky_prognostic_surface_temp\"\n\nThen run the simulation with the following command:\n\njulia --project=.buildkite .buildkite/ci_driver.jl --config_file path_to_mysim.yml\n\nThe configuration in the yaml file above can be changed to adjust to the kind of simulation desired. Options such as t_end can be increased to the desired simulation time. Other arguments such as radiation type can be changed based on the options in default_config.yml.\n\nAfter a simulation is ran the output files should be available in the output folder, where hdf5 files store all the simulation's data, and two mp4s should be produced with a vertical temperature profile and a vertical wind profile which change over time. If you want to quickly access data from the final day of the simulation simply add a -i to the command line input, like so:\n\njulia -i --project=.buildkite .buildkite/ci_driver.jl --config_file filepath\n\nThis will bring you into a julia environment where the current state of the simulation can be accessed. Run propertynames(Y) and propertynames(p) to see accessible values, some examples:\n\n(Image: )\n\nHere is a typical vertical temperature profile on the final day of a simulation (the dot is surface temperature):\n\n(Image: )\n\nNote: The surface temperature must also converge before the simulation reaches radiative equilibrium, here is a typical convergence of surface temperature plot:\n\n(Image: )","category":"section"},{"location":"radiative_equilibrium/#Greenhouse-Gas-Concentrations","page":"Radiative Equilibrium","title":"Greenhouse Gas Concentrations","text":"In radiation.jl one can change the concentrations of greenhouse gases in order to test their effects on the atmospheric temperature profile.\n\nTo change the ozone concentration multiply the following variable by the desired coefficient:\n\ncenter_volume_mixing_ratio_o3 =\n                Fields.field2array(@. FT(pressure2ozone(default_cache.ᶜp))) * desired_coefficient\n\nHere are the equilibrium temperature profiles under different ozone concentrations:\n\n(Image: ) (Image: )\n\nTo change the CO2 concentration, multiply the volume mixing ratio by the desired coefficient:\n\nvolume_mixing_ratio_co2 = input_vmr(\"carbon_dioxide_GM\") * desired_coefficient\n\nHere are the equilibrium temperature profiles under different CO2 concentrations:\n\n(Image: ) (Image: )\n\nSimilarly, one can change the concentration of any other gases in the atmosphere","category":"section"},{"location":"radiative_equilibrium/#Data-extraction-in-Julia","page":"Radiative Equilibrium","title":"Data extraction in Julia","text":"To access the data from hdf5 files one can use the following code to create a var diagnostics which stores values from a hdf5 file path:\n\nimport ClimaAtmos: time_from_filename\nimport ClimaCore: Geometry, Spaces, Fields, InputOutput\nimport ClimaComms\nimport CairoMakie: Makie\nimport Statistics: mean\n\nfunction read_hdf5_file(file_path)\n    reader =\n        InputOutput.HDF5Reader(file_path, ClimaComms.SingletonCommsContext())\n    diagnostics = InputOutput.read_field(reader, \"diagnostics\")\n    close(reader)\n    return time_from_filename(file_path), diagnostics\nend\n\ntime, diagnostics = read_hdf5_file(\"sample/file/path\")\n\ndiagnostics will contain the values from the state of the simulation at a given time. propertynames(diagnostics) can be useful for finding accessible values. For example, diagnostics.sfc_temperature contains the surface temperature at a given time in the simulation.","category":"section"},{"location":"repl_scripts/#REPL-script-(debugging-workflow-example)","page":"REPL scripts","title":"REPL script (debugging workflow example)","text":"\nca_dir = joinpath(@__DIR__, \"..\", \"..\")\nbuildkite_env = joinpath(ca_dir, \".buildkite\")\nusing Pkg\nPkg.activate(buildkite_env)\n\n# julia> using Revise # This is useful For REPL debugging. See also: Infiltrator.jl and Main.@infiltrate\n\nimport ClimaAtmos as CA\nimport SciMLBase: step!\n\n# If you wish to run your simulation on a `CUDA` device, use\n\n# import ClimaComms\n# ClimaComms.@import_required_backends\n# ENV[\"CLIMACOMMS_DEVICE\"]=\"CUDA\" \n\n# (Note that the example below runs on a single CPU, which uses \n# ENV[\"CLIMACOMMS_DEVICE\"]=\"CPU\")\n\nconfig_file = joinpath(ca_dir, \"config/model_configs/baroclinic_wave.yml\")\nconfig = CA.AtmosConfig(config_file)\n\n# Generate temporary directory for Documenter run-script, clear after \n# demo is completed. \n\ntemp_output_dir = mktempdir(ca_dir, cleanup=true)\nconfig.parsed_args[\"output_dir\"]=temp_output_dir\nsimulation = CA.AtmosSimulation(config) \n\n# Example: Advance a single timestep and explore the solution\n# stored in `simulation.integrator.u`\nstep!(simulation.integrator) \n\n# Example: Update command line argument, reset simulation, re-run to completion\n# Note that you can also to update the configuration `.yml` and \n# load the simulation again from the `config_file` as above in the same REPL session. \n# Note that you'd need to use `Revise` at the start of your session to apply changes \n# to the source code within your REPL session.\n# e.g. \n# julia> simulation = CA.AtmosSimulation(config_file)\n\n@info \"----------------------------------\"\n@info \"Update config arguments and re-run\"\n@info \"----------------------------------\"\n\nconfig.parsed_args[\"dt\"]=\"400secs\"\nconfig.parsed_args[\"t_end\"]=\"800secs\" \nsimulation = CA.AtmosSimulation(config)\nCA.solve_atmos!(simulation) \n\n@info \"----------------------------------\"\n@info \"Reactivate docs environment\"\n@info \"----------------------------------\"\n\n# The final step, which is not part of the standard workflow\n# resets the environment to `docs`.\n# (it is necessary for the documentation generation only)\nca_dir = joinpath(@__DIR__, \"..\", \"..\")\ndocs_env = joinpath(ca_dir, \"docs\")\nPkg.activate(docs_env) \n\nnothing # hide","category":"section"},{"location":"repl_scripts/#Julia-scripts-per-Buildkite-job","page":"REPL scripts","title":"Julia scripts per Buildkite job","text":"include(\"repl_scripts.jl\")","category":"section"},{"location":"contributor_guide/#Contributors-Guide","page":"Contributor Guide","title":"Contributors Guide","text":"Thank you for considering contributions to ClimaAtmos! We hope this guide helps you make a contribution.\n\nFeel free to ask us questions and chat with us at any time about any topic at all by:\n\nOpening a GitHub issue","category":"section"},{"location":"contributor_guide/#Creating-issues","page":"Contributor Guide","title":"Creating issues","text":"The simplest way to contribute to ClimaAtmos is to create or comment on issues.\n\nThe most useful bug reports:\n\nProvide an explicit code snippet –- not just a link –- that reproduces the bug in the latest tagged version of ClimaAtmos. This is sometimes called the \"minimal working example\". Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue.\nPaste the entire error received when running the code snippet, even if it's unbelievably long.\nUse triple backticks (e.g., ```some_code; and_some_more_code;```) to enclose code snippets, and other markdown formatting syntax to make your issue easy and quick to read.\nReport the ClimaAtmos version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created.\n\nDiscussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general.","category":"section"},{"location":"contributor_guide/#But-I-want-to-*code*!","page":"Contributor Guide","title":"But I want to code!","text":"New users help write ClimaAtmos code and documentation by forking the ClimaAtmos repository, using git to edit code and docs, and then creating a pull request. Pull requests are reviewed by ClimaAtmos collaborators.\nA pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, ClimaAtmos.jl collaborators will execute the merge with permission from the pull request author.\nNote: for small or minor changes (such as fixing a typo in documentation), the GitHub editor is super useful for forking and opening a pull request with a single click.\nWrite your code with love and care. In particular, conform to existing ClimaAtmos style and formatting conventions. For example, we love verbose and explicit variable names, use TitleCase for types, snake_case for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the YASGuide. It's worth few extra minutes of our time to leave future generations with well-written, readable code.","category":"section"},{"location":"contributor_guide/#General-coding-guidelines","page":"Contributor Guide","title":"General coding guidelines","text":"Keep the number of members of Julia structs small if possible (less than 8 members).\nCode should reflect \"human intuition\" if possible. This means abstraction should reflect how humans reason about the problem under consideration.\nCode with small blast radius. If your code needs to be modified or extended, the resulting required changes should be as small and as localized as possible.\nWhen you write code, write it with testing and debugging in mind.\nIdeally, the lowest level structs have no defaults for their member fields. Nobody can remember all the defaults, so it is better to introduce them at the high-level API only.\nMake sure that module imports are specific so that it is easy to trace back where functions that are used inside a module are coming from.\nConsider naming abstract Julia types \"AbstractMyType\" in order to avoid confusion for the reader of your code.\nComments in your code should explain why the code exists and clarify if necessary, not just restate the line of code in words.\nBe mindful of namespace issues when writing functional code, especially when writing function code that represents mathematical or physical concepts.\nConsider using keywords in your structs to allow readers to more effectively reason about your code.","category":"section"},{"location":"contributor_guide/#What-is-a-\"collaborator\"-and-how-can-I-become-one?","page":"Contributor Guide","title":"What is a \"collaborator\" and how can I become one?","text":"Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main ClimaAtmos repository.\nWe ask that new contributors try their hand at forking ClimaAtmos, and opening and merging a pull request before requesting collaborator status.","category":"section"},{"location":"contributor_guide/#What's-a-good-way-to-start-developing-ClimaAtmos?","page":"Contributor Guide","title":"What's a good way to start developing ClimaAtmos?","text":"Tackle an existing issue. We keep a list of good first issues that are self-contained and suitable for a newcomer to try and work on.\nTry to run ClimaAtmos and play around with it to simulate your favorite fluids and atmosphere physics. If you run into any problems or find it difficult to use or understand, please open an issue!\nWrite up an example or tutorial on how to do something useful with ClimaAtmos, like how to set up a new physical configuration.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use ClimaAtmos.\n\nIf you're interested in working on something, let us know by commenting on existing issues or  by opening a new issue. This is to make sure no one else is working on the same issue and so  we can help and guide you in case there is anything you need to know beforehand.","category":"section"},{"location":"contributor_guide/#Ground-Rules","page":"Contributor Guide","title":"Ground Rules","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"section"},{"location":"contributor_guide/#Reporting-a-bug","page":"Contributor Guide","title":"Reporting a bug","text":"The easiest way to get involved is to report issues you encounter when using ClimaAtmos or by requesting something you think is missing.\n\nHead over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. Try your best to include a complete, \"minimal working example\" that reproduces the issue.","category":"section"},{"location":"contributor_guide/#Setting-up-your-development-environment","page":"Contributor Guide","title":"Setting up your development environment","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the ClimaAtmos repository by clicking the \"Fork\" button.\nClone your fork of the ClimaAtmos repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/ClimaAtmos.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add ClimaAtmos https://github.com/CLiMA/ClimaAtmos.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure ClimaAtmos works by typing in ] test. Doing so will run all the tests (and this can take a while).\n\nYour development environment is now ready!","category":"section"},{"location":"contributor_guide/#Pull-Requests","page":"Contributor Guide","title":"Pull Requests","text":"We follow the ColPrac guide for collaborative practices. We ask that new contributors read that guide before submitting a pull request.\n\nChanges and contributions should be made via GitHub pull requests against the main branch.\n\nWhen you're done making changes, commit the changes you made. Chris Beams has written a  guide on how to write good commit messages.\n\nWhen you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.\n\nWorking on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide “How to Contribute to Open Source\".","category":"section"},{"location":"contributor_guide/#Documentation","page":"Contributor Guide","title":"Documentation","text":"Generally, we follow the Julia conventions for documentation https://docs.julialang.org/en/v1/manual/documentation/.\n\nNow that you've made your awesome contribution, it's time to tell the world how to use it. Writing documentation strings is really important to make sure others use your functionality properly. Didn't write new functions? That's fine, but be sure that the documentation for the code you touched is still in great shape. It is not uncommon to find some strange wording or clarification that you can take care of while you are here.\n\nHere is an example of a docstring:\n\nTODO: add example\n\nYou can preview how the Documentation will look like after merging by building the documentation  locally. From the main directory of your local repository call\n\njulia --project -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs/ -e 'using Pkg; Pkg.instantiate(); develop(PackageSpec(path=pwd()))'\nJULIA_DEBUG=Documenter julia --project=docs/ docs/make.jl\n\nand then open docs/build/index.html in your favorite browser. Providing the environment variable  JULIA_DEBUG=Documenter will provide with more information in the documentation build process and thus help figuring out a potential bug.","category":"section"},{"location":"contributor_guide/#Formatting","page":"Contributor Guide","title":"Formatting","text":"One of the tests consists in checking that the code is uniformly formatted. We use JuliaFormatter.jl to achieve consistent formatting. Here's how to use it:\n\nYou can install in your base environment with\n\njulia -e 'using Pkg; Pkg.add(\"JuliaFormatter\")'\n\nalongside your other development tools.\n\nThen, you can format the package running:\n\nusing JuliaFormatter; format(\".\")\n\nor just with format(\".\") if the package is already imported.\n\nThe rules for formatting are defined in the .JuliaFormatter.toml.\n\nIf you are used to formatting from the command line instead of the REPL, you can install JuliaFormatter in your base environment and call\n\njulia -e 'using JuliaFormatter; format(\".\")'\n\nYou could also define a shell alias\n\nalias julia_format_here=\"julia -e 'using JuliaFormatter; format(\\\".\\\")'\"\n\nnote: Note\n\n\nIn the past, ClimaAtmos used to have a .dev/climaformat.jl script. We moved away from it to reduce complexity in our repository and to align with the general tools used by the Julia community. If you are still using climaformat.jl, migrate to JuliaFormatter (climaformat.jl was just a wrapper around JuliaFormatter).","category":"section"},{"location":"contributor_guide/#Updating-environments","page":"Contributor Guide","title":"Updating environments","text":"The repository for ClimaAtmos includes several checked Manifests.toml. This is to help with reproducing results. PkgDevTools provides a convenient system to quickly update all the Manifests.toml. Please, refer to the documentation for more information.\n\nnote: Note\n\n\nIn the past, ClimaAtmos used to have a .dev/up_deps.jl script. We moved away from it because PkgDevTools provides a much simpler and more efficient way to accomplish the same result.","category":"section"},{"location":"contributor_guide/#Credits","page":"Contributor Guide","title":"Credits","text":"This contributor's guide is heavily based on the excellent Oceananigans.jl contributor's guide which is heavily based on the excellent MetPy contributor's guide.","category":"section"},{"location":"tracers/#Aerosols","page":"Tracers","title":"Aerosols","text":"","category":"section"},{"location":"tracers/#Trace-Gases","page":"Tracers","title":"Trace Gases","text":"ClimaAtmos implements two modes for each ozone and carbon dioxide: one time varying and one time invariant. These are only relevant for the radiation transfer, and only when RRTMGP is used. All other atmospheric gases are held fixed with default values from RRTMPG that can be changed in the toml file.","category":"section"},{"location":"tracers/#Time-Invariant-Ozone-Profile","page":"Tracers","title":"Time Invariant Ozone Profile","text":"The time invariant type of ozone uses the idealized_ozone function to compute an idealized ozone profile based on the work of Wing2018. This option is default.\n\nThe idealized_ozone function returns the ozone concentration in volume mixing ratio (VMR) at a given altitude z.\n\nThis function looks like\n\nusing CairoMakie\nimport ClimaAtmos\n\nz = range(0, 60000, length=100)\nozone = ClimaAtmos.idealized_ozone.(z)\n\nlines(ozone, z)","category":"section"},{"location":"tracers/#Time-Varying-Ozone-Profile","page":"Tracers","title":"Time Varying Ozone Profile","text":"The time varying ozone profile uses CMIP6 forcing data to prescribe ozone as read from files. A high-resolution, multi-year file is available in the ozone_concentrations artifact. This file is not small, so you have to obtain independently. Please, refer to ClimaArtifacts for more information. If the file is not found, a low-resolution, single-year version is used. This is not advised for production simulations. This option is enabled with by adding \"O3\" to the time_varying_gases config argument list, ie: time_varying_gases: [\"O3\"].\n\nWe interpolate the data from file in time every time radiation is called. The interpolation used is the LinerPeriodFilling from ClimaUtilities. This is a linear period-aware interpolation that preserves the annual cycle.","category":"section"},{"location":"tracers/#Time-Invariant-CO2-Profile","page":"Tracers","title":"Time Invariant CO2 Profile","text":"By default, CO2 concentrations are set to 397.547 ppm. The number can be altered by changing the CO2_fixed_value parameter in the toml file.","category":"section"},{"location":"tracers/#Time-Varying-CO2-Profile","page":"Tracers","title":"Time Varying CO2 Profile","text":"ClimaAtmos can prescribe CO2 concentration using data from Mauna Loa CO2 measurements. This option is enabled with by adding \"CO2\" to the time_varying_gases config argument list, ie: time_varying_gases: [\"CO2\"].","category":"section"},{"location":"tracers/#ClimaAtmos.idealized_ozone","page":"Tracers","title":"ClimaAtmos.idealized_ozone","text":"idealized_ozone(z::FT)\n\nReturns idealized ozone volume mixing ratio (VMR) from Wing et al. 2018.\n\nThe ozone profile is calculated as a function of altitude z using the following formula:\n\nO_3(z) = g_1 p^g_2 e^(-p  g_3)\n\nwhere:\n\nO_3(z) is the ozone concentration in volume mixing ratio (VMR) at altitude z.\np is the pressure at altitude z calculated using the hydrostatic equation: p = P_0 exp(-z / H_{Earth}), where P_0 is the surface pressure and H_{Earth} is the scale height of the Earth's atmosphere (assumed to be 7000 meters).\ng_1, g_2, and g_3 are empirical constants.\n\nReferences\n\nWing, A. A., et al. (2018). Radiative-convective equilibrium model intercomparison project. Geoscientific Model Development, 11(2), 663-690.\n\n\n\n\n\n","category":"function"},{"location":"config_no_table/#Creating-custom-configurations","page":"Creating custom configurations","title":"Creating custom configurations","text":"To create a custom configuration, first make a .yml file. In the file, you can set configuration arguments as key: value pairs to override the default config. YAML parsing is fairly forgiving – values will generally be parsed to the correct type. The only exception is true/false strings. These need quotes around them, or they will be parsed to Bools.\n\nTo start the model with a custom configuration, run:\n\njulia --project=.buildkite .buildkite/ci_driver.jl --config_file <yaml>","category":"section"},{"location":"config_no_table/#Example","page":"Creating custom configurations","title":"Example","text":"Below is the default Bomex configuration:\n\ninitial_condition: \"Bomex\"\nsubsidence: \"Bomex\"\nscm_coriolis: \"Bomex\"\nls_adv: \"Bomex\"\nsurface_setup: \"Bomex\"\nturbconv: \"prognostic_edmfx\"\nedmfx_upwinding: first_order\nedmfx_entr_model: \"Generalized\"\nedmfx_detr_model: \"Generalized\"\nedmfx_sgs_mass_flux: true\nedmfx_sgs_diffusive_flux: true\nedmfx_nh_pressure: true\nprognostic_tke: false\nmoist: \"equil\"\nconfig: \"box\"\nhyperdiff: true\nx_max: 1e8\ny_max: 1e8\nz_max: 3e3\nx_elem: 2\ny_elem: 2\nz_elem: 60\nz_stretch: false\nperturb_initstate: false\ndt: \"5secs\"\nt_end: \"6hours\"\ndt_save_state_to_disk: \"10mins\"\ntoml: [toml/prognostic_edmfx.toml]\n\nKeys can also point to artifacts. As artifacts are folders, we specify both the artifact name, as we would from the REPL, and file to read from, separated by a /. For example, to drive a single column model with an external forcing file from GCM output, we include the following lines in the configuration:\n\ninsolation: \"gcmdriven\"\nexternal_forcing_file: artifact\"cfsite_gcm_forcing\"/HadGEM2-A_amip.2004-2008.07.nc\n\nTo learn more about artifacts and how they're used in CliMA, visit ClimaArtifacts.jl.\n\nTo add a new configuration argument/key, open .buildkite/default_config.yml. Add an entry with the following format:\n\n<argument_name>:\n    value: <argument_value>\n    help: <help string>\n\nThe help field is optional if you don't plan on making a permanent change to the configuration argument.\n\nSee below for the full list of configuration arguments.","category":"section"},{"location":"config_no_table/#Common-Configurations","page":"Creating custom configurations","title":"Common Configurations","text":"ClimaAtmos provides a set of common numerical configurations that can be used as building blocks for different types of simulations. These configurations are located in config/common_configs/ and contain standardized settings for grid resolution, time stepping, and numerical schemes.","category":"section"},{"location":"config_no_table/#Available-Common-Configurations","page":"Creating custom configurations","title":"Available Common Configurations","text":"","category":"section"},{"location":"config_no_table/#Column-Configurations","page":"Creating custom configurations","title":"Column Configurations","text":"numerics_column_ze63.yml: Single column configuration with 63 vertical levels","category":"section"},{"location":"config_no_table/#Sphere-Configurations","page":"Creating custom configurations","title":"Sphere Configurations","text":"numerics_sphere_he6ze10.yml: Spherical configuration with 6 horizontal elements (550km), 10 vertical levels, 30km domain top, no sponge, explicit vertical diffusion\nnumerics_sphere_he6ze31.yml: Spherical configuration with 6 horizontal elements (550km) , 31 vertical levels, 60km domain top, rayleigh and viscous sponges, implicit vertical diffusion\nnumerics_sphere_he16ze63.yml: Spherical configuration with 16 horizontal elements (206km), 63 vertical levels, 60km domain top, rayleigh and viscous sponges, implicit vertical diffusion\nnumerics_sphere_he30ze43.yml: Spherical configuration with 30 horizontal elements (110km), 43 vertical levels, 30km domain top, no sponge, explicit vertical diffusion\nnumerics_sphere_he30ze63.yml: Spherical configuration with 30 horizontal elements (110km), 63 vertical levels, 60km domain top, rayleigh and viscous sponges, implicit vertical diffusion","category":"section"},{"location":"config_no_table/#Using-Common-Configurations","page":"Creating custom configurations","title":"Using Common Configurations","text":"Common configurations are designed to be used in combination with model-specific configurations. In the CI pipeline and when running simulations, you can specify multiple configuration files:\n\njulia --project=.buildkite .buildkite/ci_driver.jl \\\n  --config_file config/common_configs/numerics_sphere_he16ze63.yml \\\n  --config_file config/model_configs/your_model_config.yml\n\nThe common configuration provides the numerical setup (grid, time stepping, etc.), while the model configuration provides the physical setup (physics schemes, initial conditions, etc.). The model configuration will override any conflicting settings from the common configuration. Please modify them only if you are certain of the implications.","category":"section"},{"location":"config_no_table/#Default-Configuration","page":"Creating custom configurations","title":"Default Configuration","text":"","category":"section"},{"location":"implicit_solver/#Implicit-Solver","page":"Implicit Solver","title":"Implicit Solver","text":"The state Y is evolved using a split implicit-explicit (IMEX) timestepping scheme, which separates the tendency T(Y) = partial Ypartial t into implicit (fast) and explicit (slow) components,\n\nT(Y) = T_imp(Y) + T_exp(Y)\n\nFor an implicit step from time t to t + Delta t, we begin with the state Y_prev from the explicit step at time t (which also includes information from all previous times before t), and we find a state Y that solves the implicit equation\n\nY = Y_prev + Delta t * T_imp(Y)\n\nwhere Delta t * T_imp(Y) is a linear approximation of the state change due to the implicit tendency between times t and t + Delta t. Solving this equation amounts to finding a root of the residual function\n\nR(Y) = Y_prev + Delta t * T_imp(Y) - Y\n\nsince any state Y that satisfies R(Y) = 0 is consistent with the linear approximation of the implicit state change.\n\nNote: When we use a higher-order timestepping scheme, the full step Delta t is divided into several sub-steps or \"stages\", where the duration of stage i is Delta t * γ_i for some constant γ_i between 0 and 1.\n\nTo find the root of R(Y) using Newton's method, we must specify the derivative partial Rpartial Y. Since Y_prev does not depend on Y (it is only a function of the state at or before time t), this derivative is given by\n\nR(Y) = Delta t * fracpartial T_imppartial Y - I\n\nFor each state Y, Newton's method computes an update Delta Y that brings R(Y) closer to 0 by solving the linear equation\n\nR(Y) * Delta Y = R(Y)\n\nNote: This equation comes from assuming that there is some Delta Y for which R(Y - Delta Y) = 0 and approximating\n\nR(Y - Delta Y) approx R(Y) - R(Y) * Delta Y\n\nAfter initializing Y to Y0 = Y_prev, Newton's method executes the following steps:\n\nCompute the residual R(Y0) and its derivative R(Y0).\nSolve R(Y0) * Delta Y0 = R(Y0) for Delta Y0.\nUpdate Y to Y1 = Y0 - Delta Y0.\n\nIf the number of Newton iterations is limited to 1, this new value of Y is taken to be the solution of the implicit equation. Otherwise, this sequence of steps is repeated, i.e., Delta Y1 is computed and Y is updated to Y2 = Y1 - Delta Y1, then Delta Y2 is computed and Y is updated to Y3 = Y2 - Delta Y2, and so on until the maximum number of iterations is reached.","category":"section"},{"location":"implicit_solver/#Jacobian-Algorithms","page":"Implicit Solver","title":"Jacobian Algorithms","text":"The derivative partial Rpartial Y is represented as a ClimaAtmos.Jacobian, and the method for computing it and solving its linear equation is given by a ClimaAtmos.JacobianAlgorithm.","category":"section"},{"location":"implicit_solver/#Manual-Differentiation","page":"Implicit Solver","title":"Manual Differentiation","text":"By making certain assumptions about the physical significance of each block in the Jacobian (see Yatunin et al., Appendix F), we can obtain a sparse matrix structure that allows for an efficient linear solver. Specifically, the time and memory required to compute the sparse matrix and the time required to run the linear solver all scale linearly with respect to the number of values in each column's state vector.\n\nTo populate the nonzero entries of this sparse matrix, the ClimaAtmos.ManualSparseJacobian specifies approximate derivatives for all possible configurations of the atmosphere model, which are analytically derived from expressions used to compute the implicit tendency. This algorithm also provides flags for zeroing out blocks of the sparse matrix, where each flag corresponds to the implicit treatment of some particular physical process.","category":"section"},{"location":"implicit_solver/#Automatic-Differentiation","page":"Implicit Solver","title":"Automatic Differentiation","text":"Another way to compute the Jacobian is through automatic differentiation. This involves replacing all real numbers in the prognostic state with dual numbers of the form\n\nx^D =\nx + hatx^1 * varepsilon_1 + hatx^2 * varepsilon_2 + ldots +\n    hatx^n * varepsilon_n\n\nwhere \n\nx and hatx^i are real numbers, and\nvarepsilon_i is an infinitesimal number with the property that varepsilon_i * varepsilon_j = 0.\n\nPassing the dual number x + hatx * varepsilon to any function f(x) yields\n\nf(x + hatx * varepsilon) =\nf(x) + fracpartial f(x)partial x * hatx * varepsilon\n\nBy extension, passing the dual vector X + hatX * mathcalE, where\n\nX =\nbeginpmatrix\n    X_1 \n    X_2 \n    vdots \n    X_N\nendpmatrix\nmathcalE =\nbeginpmatrix\n    varepsilon_1 \n    varepsilon_2 \n    vdots \n    varepsilon_n\nendpmatrix\ntextrm and \nhatX =\nbeginpmatrix\n    hatX^1_1  hatX^2_1  ldots  hatX^n_1 \n    hatX^1_2  hatX^2_2  ldots  hatX^n_2 \n    vdots  vdots  ddots  vdots \n    hatX^1_N  hatX^2_N  ldots  hatX^n_N\nendpmatrix\n\nto any function f(X) yields\n\nf(X + hatX * mathcalE) =\nf(X) + fracpartial f(X)partial X * hatX * mathcalE\n\nIf the dual vector is\n\nY^D = Y + P * mathcalE\n\npassing it to the implicit tendency T_imp(Y) yields the dual tendency\n\nT_imp^D = T_imp(Y^D) =\nT_imp(Y) + fracpartial T_imp(Y)partial Y * P * mathcalE\n\nso P acts as a right preconditioner for partial T_imp(Y)partial Y. The tendency derivative can be extracted from the varepsilon components of the dual tendency by inverting the preconditioner, after which a multiplication by Delta t and subtraction of I gives the full Jacobian matrix partial R(Y)partial Y.\n\nTo be more precise, the implicit tendency is evaluated in two function calls. The first function, p_imp(Y), computes cached values that are treated implicitly, and the second function, T_imp(Y p_imp), computes the tendency itself. Further generalizing the property of varepsilon_i * varepsilon_j = 0 to functions of two vectors, passing A + hatA * mathcalE and B + hatB * mathcalE to any function f(A B) yields\n\nf(A + hatA * mathcalE B + hatB * mathcalE) =\nf(A B) +\nleft(\n    fracpartial f(A B)partial A * hatA +\n    fracpartial f(A B)partial B * hatB\nright) * mathcalE\n\nSo, the dual tendency T_imp^D is computed in two steps, first evaluating p_imp(Y^D) to get\n\np_imp^D =\np_imp(Y) + fracpartial p_imp(Y)partial Y * P * mathcalE\n\nand then evaluating T_imp(Y^D p_imp^D) to get\n\nT_imp^D =\nT_imp(Y p_imp(Y)) +\nleft(\n    fracpartial T_imp(Y p_imp(Y))partial Y +\n    fracpartial T_imp(Y p_imp(Y))partial p_imp(Y) *\n    fracpartial p_imp(Y)partial Y\nright) * P * mathcalE\n\nIn other words, the single-argument tendency derivative partial T_imp(Y)partial Y is really a shorthand for\n\nfracpartial T_imp(Y)partial Y =\nfracpartial T_imp(Y p_imp(Y))partial Y +\nfracpartial T_imp(Y p_imp(Y))partial p_imp(Y) *\nfracpartial p_imp(Y)partial Y","category":"section"},{"location":"implicit_solver/#Dense-Automatic-Differentiation","page":"Implicit Solver","title":"Dense Automatic Differentiation","text":"The simplest form of automatic differentiation uses a dense representation of the tendency matrix. When the number of varepsilon components, n, is equal to the number of values in each column's state vector, N, this involves setting P to the N times N identity matrix, so that the dual counterpart of each column's state vector is\n\nY^D = Y + mathcalE =\nbeginpmatrix\n    Y_1 + varepsilon_1 \n    Y_2 + varepsilon_2 \n    vdots \n    Y_N + varepsilon_N\nendpmatrix\n\nEvaluating T_imp(Y) on this input yields the dual tendency\n\nT_imp^D = T_imp(Y) + fracpartial T_imp(Y)partial Y * mathcalE =\nbeginpmatrix\n    T_imp 1(Y) + fracpartial T_imp 1(Y)partial Y_1 * varepsilon_1 +\n    fracpartial T_imp 1(Y)partial Y_2 * varepsilon_2 + ldots +\n    fracpartial T_imp 1(Y)partial Y_N * varepsilon_N \n    T_imp 2(Y) + fracpartial T_imp 2(Y)partial Y_1 * varepsilon_1 +\n    fracpartial T_imp 2(Y)partial Y_2 * varepsilon_2 + ldots +\n    fracpartial T_imp 2(Y)partial Y_N * varepsilon_N \n    vdots \n    T_imp N(Y) + fracpartial T_imp N(Y)partial Y_1 * varepsilon_1 +\n    fracpartial T_imp N(Y)partial Y_2 * varepsilon_2 + ldots +\n    fracpartial T_imp N(Y)partial Y_N * varepsilon_N\nendpmatrix\n\nwhere the entry in the i-th row and j-th column of partial T_imp(Y)partial Y is the coefficient of varepsilon_j in the i-th value of T_imp^D.\n\nWhen there are many values in each column, setting n = N can lead to excessive compilation latency, and often also poor performance. To compensate for this, the ClimaAtmos.AutoDenseJacobian splits the N values in each column's state vector into partitions of length n  N, where the default value of n is 32. The partitioning is implemented by setting P to N times n slices of the identity matrix (with the last slice possibly containing fewer than n columns), so that T_imp^D only contains an N times n slice of the matrix partial T_imp(Y)partial Y. Computing T_imp^D for all partitions yields the full derivative matrix.\n\nWith partial R(Y)partial Y specified as a dense matrix, the time and memory required to compute it scale in proportion to N^2. The linear equation R(Y) * Delta Y = R(Y) is solved by LU factorization, where the time required to compute the L and U factors scales as N^3. After the factors are computed, the time required to invert them scales as N^2.","category":"section"},{"location":"implicit_solver/#Sparse-Automatic-Differentiation","page":"Implicit Solver","title":"Sparse Automatic Differentiation","text":"The AutoDenseJacobian can be sped up by copying its entries into the ManualSparseJacobian. This allows the matrix to be inverted using an efficient linear solver whose runtime scales in proportion to N, rather than an LU factorization that scales as N^3. Although this improves performance on CPUs, it still results in poor runtimes compared to the sparse representation. This is especially the case on GPUs, where performance is primarily determined by memory requirements. Introducing sparsity only to avoid the factorization does not reduce the memory requirements that scale as N^2.\n\nTo make the memory requirements of automatic differentiation scale linearly with respect to N, P can be set to an N times c column coloring matrix for the tendency derivative, so that c is the smallest value for which partial T_imp(Y)partial Y * P is a lossless representation of the nonzero entries in partial T_imp(Y)partial Y. Specifically, P is a binary matrix, where a 1 in row i and column j means that the tendency derivative column corresponding to Y_i is assigned color j. Ideally, P should be chosen so that no two values Y_a andY_b can be assigned the same color if partial T_imp i(Y)partial Y_a and partial T_imp i(Y)partial Y_b are both nonzero in any row i. For any such matrix P, partial T_imp(Y)partial Y * P uniquely represents every nonzero value in the derivative matrix, so the entries of the derivative matrix can be extracted from it without any errors.\n\nThis requirement on P can be loosened so that Y_a and Y_b can still be assigned the same color as long as partial T_imp i(Y)partial Y_a and partial T_imp i(Y)partial Y_b do not have similar magnitudes. If the derivative with respect to Y_b is negligibly small compared to the derivative with respect to Y_a, then assigning Y_b the same color as Y_a might not be an issue, since this will amount to replacing the derivative partial T_imp i(Y)partial Y_a in T_imp^D with the sum   partial T_imp i(Y)partial Y_a + partial T_imp i(Y)partial Y_b, which should be approximately equal to partial T_imp i(Y)partial Y_a. When the derivatives with respect to Y_a and Y_b have comparable magnitudes, though, the sum can no longer be used to approximate either of them, and the only workaround is to assign them distinct colors.\n\nMost of the derivatives that are ignored by theManualSparseJacobian are negligibly small, so they can safely be excluded from the sparsity pattern used to assign column colors. However, some of the derivatives can be ignored based on the inputs to the linear equation in which they are used, but they do not have small magnitudes. For example, derivatives with respect to ρ tend to be much larger than derivatives with respect to ρe_tot, since a adding one kilogram of air to a cubic meter will typically have a more significant effect than adding one Joule of energy. In physical simulations, though, changes of δρ = 1 kg/m^3 tend to be much less common than changes of δρe_tot = 1 J/m^3. Generally, the amount by which δρ is smaller than δρe_tot exceeds the amount by which derivatives with respect to ρ are larger than derivatives with respect to ρe_tot, which means that those derivatives can be ignored when solving the linear equation.\n\nTo avoid introducing errors to partial T_imp(Y)partial Y, the locations of all non-negligible derivatives must be included in the sparsity pattern for assigning column colors, even if those derivatives can be ignored when solving the linear equation. In many cases, this requires the introduction of additional colors, but sometimes the coloring can be extended to include these derivatives without using more colors.\n\nThe memory requirements of this algorithm scale as N * c, which can limit the range of resolutions for which the sparse representation fits in GPU memory when c is large. To avoid this, the ClimaAtmos.AutoSparseJacobian splits the c colors into partitions of length n  c. Each partition sets P to an N times n slice of the column coloring matrix, so that T_imp^D contains an N times n slice of the tendency derivative's sparse representation. Computing T_imp^D for all partitions yields the full tendency derivative. On GPUs, the number of partitions is the smallest value for which the sparse representation fits in GPU memory (using a limit of twice the memory that is currently free); on CPUs, it is assumed that the sparse representation will always fit in memory, so only a single partition is used.\n\nWhen running the AutoSparseJacobian, care should be taken to ensure that its entries are not polluted by non-negligible derivatives from ignored blocks (or from ignored bands within nonzero blocks). Whenever debugging reveals a difference between the nonzero values generated by sparse and dense automatic differentiation, ignored derivatives are almost always at fault. The default \"padding bands\" added to the coloring sparsity pattern should handle most non-negligible derivatives (such as the aforementioned derivatives with respect to ρ), but new variables and tendencies may require additional padding bands. For cases where the new padding bands that need to be added are not known in advance, the AutoSparseJacobian also has an option to add a fixed number of padding bands to every Jacobian block.","category":"section"},{"location":"implicit_solver/#Debugging-Sparse-Automatic-Differentiation-Errors","page":"Implicit Solver","title":"Debugging Sparse Automatic Differentiation Errors","text":"If setting use_auto_jacobian = true makes a simulation unstable or leads to inaccurate results, set debug_jacobian = true and compare the different approximations of each Jacobian block:\n\nWhen a block differs between two algorithms, check whether the difference is significant (i.e., whether its normalized magnitude exceeds 1/dt).\nIf the AutoSparseJacobian and ManualSparseJacobian agree on a block but significantly differ from the AutoDenseJacobian:\nAdd bands that are missing from the sparsity pattern in this block to the ManualSparseJacobian, which also adds them to the AutoSparseJacobian.\nIf the AutoSparseJacobian and AutoDenseJacobian agree on a block but significantly differ from the ManualSparseJacobian, and if the manual approximation is more accurate than the automatic value:\nDetermine which tendency term's derivative is responsible for the erroneous automatic value.\nIf possible, rewrite the tendency term so that it generates a more accurate derivative using dual numbers.\nIf this is not possible, add a new method for the tendency term that specializes on dual numbers with the tag ClimaAtmos.Jacobian, overwriting the derivative automatically generated by ForwardDiff.jl.\nOtherwise, if the AutoSparseJacobian and AutoDenseJacobian significantly differ for a block:\nSet auto_jacobian_padding_bands to a large number, and check whether this discrepancy between the sparse and dense values disappears.\nIf padding bands do not resolve the discrepancy:\nAdd non-padding bands that are missing from this block to the ManualSparseJacobian, which also adds them to the AutoSparseJacobian.\nIf padding bands resolve the discrepancy:\nFind all differences between the sparsity patterns of the sparse and dense Jacobians in the same row as this block.\nIf any blocks (or bands within a block) are missing from this block's row of the sparse Jacobian, check whether they have unnormalized magnitudes that are significant in comparison to this block.\nExtend the default padding bands of the AutoSparseJacobian so they cover every significant unnormalized value that could be affecting this block, and reset auto_jacobian_padding_bands to use the default padding bands.","category":"section"},{"location":"implicit_solver/#See-also","page":"Implicit Solver","title":"See also","text":"Yatunin, D, et al., \"The CliMA atmosphere dynamical core: Concepts, numerics, and scaling\", Section 5 and Appendix F\nDocumentation for ClimaTimeSteppers.jl","category":"section"},{"location":"restarts/#Restarting-Simulations-in-ClimaAtmos","page":"Restarts and checkpoints","title":"Restarting Simulations in ClimaAtmos","text":"ClimaAtmos supports restarting simulations from previously saved checkpoints, allowing you to split simulations across multiple runs. This feature is particularly useful for\n\nPerforming long simulations on clusters: Most supercomputers do not allow jobs to run for an unlimited amount of wall-time. So, instead of running multi-year simulation in a single run, you can break it down into shorter segments, restarting from the last saved state.\nRecovery from interruptions: If a simulation is unexpectedly interrupted (e.g., due to a crash), you can resume it from the last saved checkpoint instead of starting over.\nSensitivity experiments: You can run a simulation to a certain point, then branch it off into multiple simulations with modified parameters or initial conditions, restarting from the common checkpoint.\n\nnote: Note\nIn the current version, restarting a simulation will check if the AtmosModel used to produce the restart file is identical to the new one and throw a warning if that is not the case. When the warning is produced, it is your responsability to ensure that what you are doing makes sense.\n\nnote: Note\nBy default, the simulation cannot be restarted in a reproducible way. To enable reproducible restarts, you need to set reproducible_restart to true.  When reproducible_restart is true, ClimaAtmos recalculates the grid_scale  cloud fraction and uses it in the buoyancy gradient calculation to ensure deterministic  behavior across restarts. We recommend disabling this option for production runs.","category":"section"},{"location":"restarts/#How-Restarts-Work","page":"Restarts and checkpoints","title":"How Restarts Work","text":"ClimaAtmos periodically saves the simulation state to a file called a \"restart file\". This file contains all the necessary information to resume the simulation from that point, including the values of all prognostic variables. The frequency of saving restart files can be configured in the simulation settings using the dt_save_state_to_disk option.\n\nRestart files are HDF5 files that contain the state Y of the simulation at the time of checkpoint. Then, the run restarted by preparing a new simulation as specified by the new configuration, but using the state read from file. The values of non-prognostic variables is computed again.\n\nClimaAtmos can automatically detect the latest restart file within a structured output directory generated using the ActiveLinkStyle. When ClimaAtmos is configured to do (e.g., with the detect_restart_file option), ClimaAtmos will scan previous output directories for the most recent file that matches the expected name for a restart file. If none is found, a new simulation is started.\n\nIf is also possible to manually specify a restart file. In this case, this will override any file automatically detected.\n\nClimaAtmos also comes with a configuration,t_start, to change the initial time of the simulation without changing the start date. This option can be useful manually restarting a simulation (e.g., by overwriting the initial conditions). When a simulation is restarted from a checkpoint, this option becomes redundant.","category":"section"},{"location":"restarts/#Accumulated-Diagnostics","page":"Restarts and checkpoints","title":"Accumulated Diagnostics","text":"At the moment, ClimaAtmos does not support working with accumulated diagnostics across restarts. The present limitations are best illustrated with an example.\n\nSuppose you are saving 30-day averages and stop the simulation at day 45. If you do so, you'll find output for day 30 and the checkpoint at day 45. Then, if you restart the simulation, you'll see that the next diagnostic output will be at day 75, and not day 60. In other words, the counter starts from 0 with every restart.\n\nnote: Note\nIf you care about accurate accumulated diagnostics, make sure to line up your checkpoint and diagnostic frequencies.","category":"section"},{"location":"getting_started/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"ClimaAtmos is provided as a Julia package, so it requires having Julia installed. Information about Julia packages is available on the Julia website.\n\nFirst, download and install Julia by following the instructions at https://julialang.org/downloads/. Then, you can launch a Julia REPL by running $ julia --project","category":"section"},{"location":"getting_started/#Installing-ClimaAtmos.jl","page":"Getting Started","title":"Installing ClimaAtmos.jl","text":"ClimaAtmos.jl is a registered Julia package. To install\n\njulia> using Pkg\n\njulia> Pkg.add(\"ClimaAtmos\")\n\nAlternatively, you can clone the ClimaAtmos repository with:\n\n$ git clone https://github.com/CliMA/ClimaAtmos.jl.git\n\nThis is useful if you want to keep up with bleeding-edge changes between major releases.\n\nNow change into the ClimaAtmos.jl directory with \n\n$ cd ClimaAtmos.jl\n\nTo use ClimaAtmos, you need to instantiate all dependencies with:\n\n$ julia --project\njulia> ]\n(ClimaAtmos) pkg> instantiate","category":"section"},{"location":"getting_started/#Some-common-terminology-in-ClimaAtmos","page":"Getting Started","title":"Some common terminology in ClimaAtmos","text":"The following terms are frequently used within the source code and between collaborators. Feel free to open a GitHub issue if you come across any other key terms that we've missed here.\n\nYₜ: The tendency state vector, where Yₜ.sfc components are modified.\nY: The current state vector.\np: Cache containing parameters, precomputed fields (radiation fluxes, surface      conditions, precipitation fluxes), atmospheric model configurations, and      slab model properties.\nt: Current simulation time.\n\nThe state Y is not assigned by default. If you want to explore the state variable, you can follow the steps below. Note that all but the last step below are executed by the driver.\n\nimport ClimaAtmos as CA\nconfig = CA.AtmosConfig([your_path_to_config_file])\nsimulation = CA.get_simulation(config)\nY = simulation.integrator.u","category":"section"},{"location":"itime/#ITime","page":"The time type","title":"ITime","text":"ITime, or integer time, is a time type used by CliMA simulations to keep track of simulation time. For more information, refer to the TimeManager section  in ClimaUtilities.","category":"section"},{"location":"itime/#Why-not-use-floating-point-for-simulation-time?","page":"The time type","title":"Why not use floating point for simulation time?","text":"Due to floating point errors, time can easily be inaccurate or stop incrementing (especially with Float32). For instance, consider the example below.\n\n0.1 + 0.1 + 0.1 == 0.3\n\nIf t = 0 and dt = 0.1, then the time of the simulation is already wrong when the simulation done just three time steps. This can easily accumulate into a larger error.\n\nAdditionally, time can stop incrementing as seen below.\n\nFloat32(16777216) + Float32(1) == Float32(16777216)\n\nIn the expression above, if the number represents seconds, then time stops incrementing after about 194 days.\n\nThese issues propagate and lead to problems as we cannot reliably depend on the simulation time to be accurate. For instance, dates will always be wrong when converting from simulation time to date. Since dates are wrong, the diagnostics are saved after one timestep than they should be.\n\nThese are the issues that ITime aims to solve.","category":"section"},{"location":"itime/#Introduction-to-ITime","page":"The time type","title":"Introduction to ITime","text":"ITime consists of three fields: counter, period, and epoch. The counter keeps track of the number of periods since the epoch if it exists. See the examples below of constructing an ITime.\n\nusing ClimaUtilities.TimeManager, Dates # ITime is from ClimaUtilities\nx = ITime(3, period = Minute(1), epoch = DateTime(2010))\ncounter(x)\nperiod(x)\nepoch(x)\n\nITimes can be thought of as a number with units. Hence, addition and subtraction is what we expected, but multiplication between ITimes is not defined and division results in a number rather than an ITime. For more information about what functions are available for ITime, see the API at ClimaUtilities.\n\ny = ITime(60, period = Second(1), epoch = DateTime(2010))\nx + y\nx - y\nx / y","category":"section"},{"location":"itime/#How-do-I-use-ITime-in-my-simulation?","page":"The time type","title":"How do I use ITime in my simulation?","text":"In this section, we address how to use ITime instead of floating point for time in a ClimaAtmos simulation and how to write code with ITime in mind.\n\nIf you are running a simulation from a YAML file, you can simply set use_itime to true to enable ITime. If you do not want to use ITime, then set use_itime to false to not use ITime which will use floating point instead.\n\nnote: Different results from rounding using `ITime`\nIf a is a floating point number and t is an ITime, then we round a * t to the nearest integer for the counter, while keeping the same period and epoch if it exists. As a result, the simulation will run at a resolution of the period used for ITime. This could leads to slight differences in the surface conditions and the time dependent forcing and tendencies that explicitly depend on time.\n\nnote: Different results from `float` on `ITime`\nUsing float on an ITime returns a Float64. As such, a simulation running Float32 and a simulation running ITime for time and Float32 for everything else will return different results.","category":"section"},{"location":"itime/#Developing-with-ITime","page":"The time type","title":"Developing with ITime","text":"Some helpful functions when working with ITimes are float, date, and promote.\n\nWhen working with ITime, you might need t, an ITime, to be the number of seconds. This can be done by using the function float on t. For other cases, you might need the current date which you can get by using the function date on t. Finally, when working with ITimes, the types of the ITimes might not match (e.g. the periods are different). To handle this, you can use promote on the two ITimes. For more information about developing with ITime, see the ITime documentation  in ClimaUtilities.\n\nfloat(x)\ndate(x)\npromote(x, y)","category":"section"},{"location":"diagnostic_edmf_equations/#Diagnostic-EDMF-equations","page":"Diagnostic EDMF Equations","title":"Diagnostic EDMF equations","text":"This describes the diagnostic EDMF scheme equations and its discretizations. Where possible, we use a coordinate invariant form: the ClimaCore operators generally handle the conversions between bases internally.","category":"section"},{"location":"diagnostic_edmf_equations/#Grid-scale-variables","page":"Diagnostic EDMF Equations","title":"Grid-scale variables","text":"rho: density in kg/m³, discretized at cell centers.\nu^3: the contravariant 3 component of velocity, discretized at cell faces.\nh_mathrms: moist static energy in J/kg, discretized at cell centers.\nq_t: total specific humidity in kg/kg, discretized at cell centers.\nPhi = g z: geopotential in m²/s², where g is the gravitational acceleration rate and z is altitude above the mean sea level, discretized at cell centers.\n(nabla Phi)^3: the contravariant 3 component of the gradient of geopotential, reconstructed at cell centers.\np: air pressure, reconstructed at cell centers.","category":"section"},{"location":"diagnostic_edmf_equations/#Subgrid-scale-variables","page":"Diagnostic EDMF Equations","title":"Subgrid-scale variables","text":"hatrho^j: effective density in kg/m³. Superscript j represents the sub-domain. hatrho^j = rho^j a^j where rho^j is the sub-domain density and a^j is the sub-domain area fraction. This is discretized at cell centers.\nrho^j: density in kg/m³, derived from the thermodynamic state, reconstructed at cell centers.\nb^j3: the contravariant 3 component of the buoyancy of updraft, reconstructed at cell centers. \nb^j3 = - fracrho^j-rhorho^j (nabla Phi)^3\nu^j3: the contravariant 3 component of velocity, discretized at cell faces.\nh_mathrms^j: moist static energy, discretized at cell centers.\nq_t^j: total specific humidity of the sub-domain j, discretized at cell centers.\nu^03: the contravariant 3 component of the environmental velocity, obtained as the residual:\nrho u^0 3 = rho u^3 -  sum_jne 0 hatrho^j u^j 3","category":"section"},{"location":"diagnostic_edmf_equations/#Equations-and-discretizations","page":"Diagnostic EDMF Equations","title":"Equations and discretizations","text":"","category":"section"},{"location":"diagnostic_edmf_equations/#Mass","page":"Diagnostic EDMF Equations","title":"Mass","text":"frac1J fracpartialpartial xi^3 bigl( hatrho^j J u^j 3 bigr)\n= (E^j0 - Delta^j0) hatrho^j\n\nThis is descritized using the following\n\nfrac1Ji-1 left( Ji-frac12 hatrho^ji u^(j) 3i-frac12 -Ji-frac32 hatrho^ji-1 u^j 3i-frac32 right)\n= (E^j0i-1 - Delta^j0i-1) hatrho^ji-1","category":"section"},{"location":"diagnostic_edmf_equations/#Momentum","page":"Diagnostic EDMF Equations","title":"Momentum","text":"frac1J^2 fracpartialpartial xi^3  bigl(frac12 J^2 (u^j 3)^2 bigr)\n= b^j 3 + E^j0(u^03 - u^j3) - d^j 3\n\nThis is descritized using the following\n\nfrac12 frac1Ji-1^2 left( Ji-frac12^2 u^j 3i-frac12^2 -Ji-frac32 u^j 3i-frac32^2 right)\n= - fracrho^ji-1-rhoi-1rho^ji-1 nabla^3 Phi + E^j0i-1(u^0 3i-frac32 - u^j 3i-frac32) - d^j 3i-1","category":"section"},{"location":"diagnostic_edmf_equations/#Total-energy","page":"Diagnostic EDMF Equations","title":"Total energy","text":"frac1J fracpartialpartial xi^3 ( hatrho^j J h_mathrms^j u^j 3 )\n= - u^j3 cdot b^j_3 + hatrho^j left(E^j0 h_mathrms - Delta^j0 h_mathrms^jright)\n\nThis is descritized using the following\n\nfrac1Ji-1 left( Ji-frac12 hatrho^ji u^j 3i-frac12 h_mathrms^ji -Ji-frac32 hatrho^ji-1 u^j 3i-frac32 h_mathrms^ji-1 right)\n= hatrho^ji-1 (E^(j0)i-1 h_mathrmsi-1  - Delta^(j0)i-1 h_mathrms^ji-1)","category":"section"},{"location":"diagnostic_edmf_equations/#Total-water","page":"Diagnostic EDMF Equations","title":"Total water","text":"frac1J fracpartialpartial xi^3 bigl(hatrho^j J q_t^j (u^j 3 - W_t^j hat k^3) bigr)\n= hatrho^j left(E^j0 q_t - Delta^j0 q_t^jright)\n\nThis is descritized using the following\n\nfrac1Ji-1 left( Ji-frac12 hatrho^ji u^j 3i-frac12 q_t^ji -Ji-frac32 hatrho^ji-1 u^j 3i-frac32 q_t^ji-1 right)\n= hatrho^ji-1 (E^j0i-1 q_ti-1  - Delta^j0i-1 q_t^ji-1)","category":"section"},{"location":"#ClimaAtmos.jl","page":"Home","title":"ClimaAtmos.jl","text":"ClimaAtmos.jl is a library for building atmospheric circulation models that is designed from the outset to leverage data assimilation and machine learning tools.","category":"section"}]
}
